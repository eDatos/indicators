-- --------------------------------------------------------------------------------------------------
-- EDATOS-3359 - Incidencia con versionado de dataset e importación de datos en Postgresql
-- --------------------------------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION RANDOM_STRING(numeric)
RETURNS text
AS $$ 
  SELECT array_to_string(
    ARRAY (
      SELECT substring('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' FROM (random() * 26 + 1)::int FOR 1) -- + 1 en random porque a veces generaba substring de 1 vacío 
      FROM generate_series(1, $1) ), '' ) 
$$ LANGUAGE sql;


CREATE OR REPLACE FUNCTION CLONE_OBSERVATIONS(P_OLD_DATASET_ID numeric, 
											  P_OLD_TABLE_NAME text,
											  P_NEW_TABLE_NAME text)
RETURNS void AS
$$
DECLARE
	SEQ_DESTINO	 			text;
	SEQ_ORIGEN	  			text;
	SEQ_ORIGEN_NEXT_VALUE 	numeric;
	VA_COUNTER 				numeric;
	VA_TMP					text;
	VA_ALL_DIMENSIONS		text;
	VA_TMP_DIMENSION_COLUMN_NAME	text;
	
	CURSOR_TB_DATASET_DIMENSIONS CURSOR FOR
	 	SELECT *
		FROM TB_DATASET_DIMENSIONS
		WHERE DATASET_FK = P_OLD_DATASET_ID;
		
	ROW_TB_DATASET_DIMENSIONS RECORD;
	
BEGIN
	-- Create table
	EXECUTE 'CREATE TABLE ' || P_NEW_TABLE_NAME || ' AS (SELECT * FROM ' || P_OLD_TABLE_NAME || ')';

	-- Create sequence
	SEQ_ORIGEN  := 'SEQ' || SUBSTRING(P_OLD_TABLE_NAME  FROM POSITION('_' IN P_OLD_TABLE_NAME));
	SEQ_DESTINO := 'SEQ' || SUBSTRING(P_NEW_TABLE_NAME FROM POSITION('_' IN P_NEW_TABLE_NAME));
	EXECUTE 'SELECT LAST_VALUE + 1 FROM ' || SEQ_ORIGEN || '' INTO SEQ_ORIGEN_NEXT_VALUE;
	EXECUTE 'CREATE SEQUENCE ' || SEQ_DESTINO || ' START WITH ' || SEQ_ORIGEN_NEXT_VALUE;

    -- Primary key
	EXECUTE 'ALTER TABLE ' || P_NEW_TABLE_NAME || ' ADD PRIMARY KEY (ID)';
	
	-- Dimensions: not null, create index, unique constraint
	SELECT COUNT (1)
	INTO VA_COUNTER
	FROM TB_DATASET_DIMENSIONS
	WHERE DATASET_FK = P_OLD_DATASET_ID;
	
	VA_ALL_DIMENSIONS := '';
	IF VA_COUNTER > 0
	THEN
		OPEN CURSOR_TB_DATASET_DIMENSIONS;
		LOOP
		    FETCH CURSOR_TB_DATASET_DIMENSIONS INTO ROW_TB_DATASET_DIMENSIONS;
	        EXIT WHEN NOT FOUND;
	
			VA_TMP := SUBSTRING(ROW_TB_DATASET_DIMENSIONS.COLUMN_NAME FROM POSITION('_' IN ROW_TB_DATASET_DIMENSIONS.COLUMN_NAME));
	        VA_TMP_DIMENSION_COLUMN_NAME := 'DIMENSION' || VA_TMP;
			
	        IF VA_ALL_DIMENSIONS <> ''
	        THEN
	        	VA_ALL_DIMENSIONS := VA_ALL_DIMENSIONS || ', ';
	        END IF;
			VA_ALL_DIMENSIONS := VA_ALL_DIMENSIONS || VA_TMP_DIMENSION_COLUMN_NAME;
			
		    -- Example: ALTER TABLE data_ui07ui8wlulw95ppxsh6o1b ALTER COLUMN DIMENSION_00 SET NOT NULL
			EXECUTE 'ALTER TABLE ' || P_NEW_TABLE_NAME || ' ALTER COLUMN ' || VA_TMP_DIMENSION_COLUMN_NAME || ' SET NOT NULL';
	
		    -- Example: CREATE INDEX IDX_ui07ui8wlulw95ppxsh6o1b_00 ON data_ui07ui8wlulw95ppxsh6o1b (DIMENSION_00)
			EXECUTE 'CREATE INDEX IDX_' || SUBSTRING(P_NEW_TABLE_NAME, 6) || VA_TMP || ' ON ' || P_NEW_TABLE_NAME || ' (' || VA_TMP_DIMENSION_COLUMN_NAME || ')';
	    END LOOP;
	    CLOSE CURSOR_TB_DATASET_DIMENSIONS;

	    -- Example: ALTER TABLE data_ui07ui8wlulw95ppxsh6o1b ADD CONSTRAINT UQ_ui07ui8wlulw95ppxsh6o1b UNIQUE (DIMENSION_00, DIMENSION_01)
    	EXECUTE 'ALTER TABLE ' || P_NEW_TABLE_NAME || ' ADD CONSTRAINT UQ' || SUBSTRING(P_NEW_TABLE_NAME  FROM POSITION('_' IN P_NEW_TABLE_NAME)) || ' UNIQUE (' || VA_ALL_DIMENSIONS || ')';
    END IF;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION CLONE_TB_DATASETS(P_OLD_ID numeric,
											 P_DATASET_ID text,
											 P_TABLE_NAME text)
RETURNS numeric AS
$$
DECLARE
	VA_SEQ	numeric;
BEGIN

	SELECT nextval('SEQ_DATASETS') INTO VA_SEQ;

	INSERT INTO TB_DATASETS
		(ID, DATASET_ID, TABLE_NAME, MAX_ATTRIBUTES_OBSERVATION, LANGUAGES, UUID, VERSION)
		(SELECT VA_SEQ AS ID,
			P_DATASET_ID AS DATASET_ID,
			P_TABLE_NAME AS TABLE_NAME,
			MAX_ATTRIBUTES_OBSERVATION AS MAX_ATTRIBUTES_OBSERVATION,
			LANGUAGES AS LANGUAGES,
			RANDOM_STRING(36) AS UUID,
			VERSION AS VERSION
		FROM TB_DATASETS
		WHERE ID = P_OLD_ID);

	RETURN VA_SEQ;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION CLONE_TB_DATASET_DIMENSIONS(P_OLD_ID numeric,
													   P_NEW_ID numeric)
RETURNS void AS
$$
DECLARE
	VA_COUNTER   numeric;
BEGIN
	SELECT COUNT (1)
	INTO VA_COUNTER
	FROM TB_DATASET_DIMENSIONS
	WHERE DATASET_FK = P_OLD_ID;

	IF VA_COUNTER > 0
	THEN
		INSERT INTO TB_DATASET_DIMENSIONS
			(ID, DIMENSION_ID, COLUMN_NAME, UUID, VERSION, DATASET_FK)
			(SELECT nextval('SEQ_DASET_DIMS') AS ID,
                    DIMENSION_ID AS DIMENSION_ID,
                    COLUMN_NAME AS COLUMN_NAME,
                    RANDOM_STRING(36) AS UUID,
                    VERSION AS VERSION,
                    P_NEW_ID AS DATASET_FK
			FROM TB_DATASET_DIMENSIONS
			WHERE DATASET_FK = P_OLD_ID);
	END IF;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION CLONE_TB_DATASET_ATTRIBUTES(P_OLD_ID numeric,
													   P_NEW_ID numeric)
RETURNS void AS
$$
DECLARE
	VA_COUNTER   numeric;
BEGIN
	SELECT COUNT (1)
	INTO VA_COUNTER
	FROM TB_DATASET_ATTRIBUTES
	WHERE DATASET_FK = P_OLD_ID;

	IF VA_COUNTER > 0
	THEN
		INSERT INTO TB_DATASET_ATTRIBUTES
			(ID, ATTRIBUTE_ID, COLUMN_NAME, COLUMN_INDEX, UUID, VERSION, DATASET_FK, ATTACHMENT_LEVEL)
			(SELECT nextval('SEQ_DATASET_ATTRIBUTES') AS ID,
					ATTRIBUTE_ID AS ATTRIBUTE_ID,
                    COLUMN_NAME AS COLUMN_NAME,
                    COLUMN_INDEX AS COLUMN_INDEX,
                    RANDOM_STRING(36) AS UUID,
                    VERSION AS VERSION,
                    P_NEW_ID AS DATASET_FK,
                    ATTACHMENT_LEVEL AS ATTACHMENT_LEVEL
			FROM TB_DATASET_ATTRIBUTES
			WHERE DATASET_FK = P_OLD_ID);
	END IF;
END;
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION CLONE_TB_INTERNACIONAL_STRINGS(P_OLD_ID numeric)
RETURNS numeric AS
$$
DECLARE
	VA_SEQ        numeric;
	VA_COUNTER   numeric;
BEGIN
	SELECT COUNT (1)
	INTO VA_COUNTER
	FROM TB_INTERNATIONAL_STRINGS
	WHERE ID = P_OLD_ID;

	IF VA_COUNTER > 0
	THEN
		SELECT nextval('SEQ_I18NSTRS') INTO VA_SEQ;

		INSERT INTO TB_INTERNATIONAL_STRINGS
		(ID, UUID, VERSION)
		(SELECT VA_SEQ AS ID,
			  RANDOM_STRING(36) AS UUID,
			  VERSION AS VERSION
		   FROM TB_INTERNATIONAL_STRINGS
		  WHERE ID = P_OLD_ID);
	ELSE
	   VA_SEQ := NULL;
	END IF;

	RETURN VA_SEQ;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION CLONE_TB_LOCALISED_STRINGS(P_INTERNATIONAL_STRING_OLD_ID numeric,
													  P_INTERNATIONAL_STRING_NEW_ID numeric)
RETURNS void AS
$$
DECLARE
	VA_COUNTER   numeric;
BEGIN
	SELECT COUNT (1)
	INTO VA_COUNTER
	FROM TB_LOCALISED_STRINGS
	WHERE INTERNATIONAL_STRING_FK = P_INTERNATIONAL_STRING_OLD_ID;

	IF VA_COUNTER > 0
	THEN
		INSERT INTO TB_LOCALISED_STRINGS
		(ID, LABEL, LOCALE, UUID, VERSION, INTERNATIONAL_STRING_FK)
            (SELECT nextval('SEQ_L10NSTRS') AS ID,
                    LABEL AS LABEL,
                    LOCALE AS LOCALE,
                    RANDOM_STRING(36) AS UUID,
                    VERSION AS VERSION,
                    P_INTERNATIONAL_STRING_NEW_ID AS INTERNATIONAL_STRING_FK
			FROM TB_LOCALISED_STRINGS
            WHERE INTERNATIONAL_STRING_FK = P_INTERNATIONAL_STRING_OLD_ID);
      END IF;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION CLONE_TB_ATTRIBUTE_DIMENSIONS(P_OLD_ATTRIBUTES_ID numeric,
														 P_NEW_ATTRIBUTES_ID numeric)
RETURNS void AS
$$
DECLARE
	VA_COUNTER   numeric;
BEGIN
	SELECT COUNT (1)
	INTO VA_COUNTER
	FROM TB_ATTRIBUTE_DIMENSIONS
	WHERE ATTRIBUTE_FK = P_OLD_ATTRIBUTES_ID;

	IF VA_COUNTER > 0
	THEN
		INSERT INTO TB_ATTRIBUTE_DIMENSIONS
			(ID, DIMENSION_ID, CODE_DIMENSION_ID, UUID, VERSION, ATTRIBUTE_FK)
			(SELECT nextval('SEQ_ATTR_DIMS') AS ID,
                    DIMENSION_ID AS DIMENSION_ID,
                    CODE_DIMENSION_ID AS CODE_DIMENSION_ID,
                    RANDOM_STRING(36) AS UUID,
                    VERSION AS VERSION,
                    P_NEW_ATTRIBUTES_ID AS ATTRIBUTE_FK
			FROM TB_ATTRIBUTE_DIMENSIONS
			WHERE ATTRIBUTE_FK = P_OLD_ATTRIBUTES_ID);
	END IF;
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION CLONE_TB_ATTRIBUTES (P_OLD_DATASET_ID numeric,
												P_NEW_DATASET_ID numeric)
RETURNS void AS
$$
DECLARE
	VA_SEQ                        numeric;
	VA_INTERNATIONAL_STRINGS_ID   numeric;
	
	 CURSOR_TB_ATTRIBUTES CURSOR FOR
	 	SELECT *
		FROM TB_ATTRIBUTES
		WHERE DATASET_FK = P_OLD_DATASET_ID;
		
	ROW_TB_ATTRIBUTES RECORD;
BEGIN

	OPEN CURSOR_TB_ATTRIBUTES;
	LOOP
	    FETCH CURSOR_TB_ATTRIBUTES INTO ROW_TB_ATTRIBUTES;
        EXIT WHEN NOT FOUND;
	
        SELECT nextval('SEQ_ATTRIBUTES') INTO VA_SEQ;
        
		VA_INTERNATIONAL_STRINGS_ID := CLONE_TB_INTERNACIONAL_STRINGS(ROW_TB_ATTRIBUTES.VALUE_FK);
		PERFORM CLONE_TB_LOCALISED_STRINGS(ROW_TB_ATTRIBUTES.VALUE_FK, VA_INTERNATIONAL_STRINGS_ID);

		INSERT INTO TB_ATTRIBUTES
			(ID, ATTRIBUTE_ID, UUID, VERSION, VALUE_FK, DATASET_FK)
			VALUES (VA_SEQ,
					ROW_TB_ATTRIBUTES.ATTRIBUTE_ID,
					RANDOM_STRING(36),
					ROW_TB_ATTRIBUTES.VERSION,
					VA_INTERNATIONAL_STRINGS_ID,
					P_NEW_DATASET_ID);

		PERFORM CLONE_TB_ATTRIBUTE_DIMENSIONS(ROW_TB_ATTRIBUTES.ID, VA_SEQ);
    END LOOP;
    CLOSE CURSOR_TB_ATTRIBUTES;  
END;
$$ LANGUAGE plpgsql;



CREATE OR REPLACE FUNCTION CREATE_VERSION (P_DATASET_OLD text,
										   P_DATASET_NEW text)
RETURNS void AS
$$
DECLARE
	VA_NEW_TABLE_NAME		text;
	VA_OLD_TABLE_NAME   text;
	VA_OLD_DATASET_ID   numeric;
	VA_NEW_DATASET_ID   numeric;
	VA_COUNTER			numeric;
BEGIN
	
	VA_NEW_TABLE_NAME := 'DATA_' || RANDOM_STRING(23);
	
	-- Obtenemos el nombre de la tabla vieja y el id
	SELECT ID, TABLE_NAME
	INTO VA_OLD_DATASET_ID, VA_OLD_TABLE_NAME
	FROM TB_DATASETS
	WHERE DATASET_ID = P_DATASET_OLD;

	VA_NEW_DATASET_ID := CLONE_TB_DATASETS(VA_OLD_DATASET_ID, P_DATASET_NEW, VA_NEW_TABLE_NAME);
	PERFORM CLONE_TB_DATASET_DIMENSIONS (VA_OLD_DATASET_ID, VA_NEW_DATASET_ID);
	PERFORM CLONE_TB_DATASET_ATTRIBUTES (VA_OLD_DATASET_ID, VA_NEW_DATASET_ID);
	PERFORM CLONE_TB_ATTRIBUTES(VA_OLD_DATASET_ID, VA_NEW_DATASET_ID);
	PERFORM CLONE_OBSERVATIONS(VA_OLD_DATASET_ID, VA_OLD_TABLE_NAME, VA_NEW_TABLE_NAME);
   
	-- NOTE: Exception handling to delete possible elements created is not necessary, due to PostgreSQL ddl are transactional
END;
$$ LANGUAGE plpgsql;