
import "classpath:/btdesign/export/metamac-core-common-entity.btdesign"
import "classpath:/btdesign/metamac-core-common-dtos.btdesign"
import "classpath:/btdesign/metamac-core-common-enum.btdesign"
import "classpath:/btdesign/metamac-core-common-enum-time.btdesign"

Application Indicators {
    basePackage=es.gobcan.istac.indicators
    
    Module core {
		basePackage=es.gobcan.istac.indicators.core
		
		// ----------------------------------------------------------------
		// 							SERVICES
		// ----------------------------------------------------------------     
		
		"Provides access to indicators systems"
    	Service IndicatorsSystemsService {
    		> @IndicatorsSystemRepository
    		> @IndicatorsSystemVersionRepository
    		> @DimensionRepository
    		> @IndicatorInstanceRepository
    		> @ElementLevelRepository
    		> @IndicatorRepository
    		> @IndicatorsSystemHistoryRepository
    		> @GeographicalValueRepository
    		> @GeographicalGranularityRepository
    		> @TranslationRepository
    		> @IndicatorInstanceLastValueCacheRepository
    		> @IndicatorsDataService
    		
    		// Indicators system
    		@IndicatorsSystemVersion createIndicatorsSystem(@IndicatorsSystemVersion indicatorsSystemVersion) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystem(String uuid, String versionNumber) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystemPublished(String uuid) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystemByCode(String code, String versionNumber) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystemPublishedByCode(String code) throws MetamacException;
	    	List<@ElementLevel> retrieveIndicatorsSystemStructure(String uuid, String versionNumber) throws MetamacException;
	    	deleteIndicatorsSystem(String uuid) throws MetamacException;
	    	PagedResult<@IndicatorsSystemVersion> findIndicatorsSystems(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	PagedResult<@IndicatorsSystemVersion> findIndicatorsSystemsPublished(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	@IndicatorsSystemVersion sendIndicatorsSystemToProductionValidation(String uuid) throws MetamacException;
	    	@IndicatorsSystemVersion rejectIndicatorsSystemProductionValidation(String uuid) throws MetamacException;
	    	@IndicatorsSystemVersion sendIndicatorsSystemToDiffusionValidation(String uuid) throws MetamacException;
	    	@IndicatorsSystemVersion rejectIndicatorsSystemDiffusionValidation(String uuid) throws MetamacException;
	    	@IndicatorsSystemVersion publishIndicatorsSystem(String uuid) throws MetamacException;	    		    	
	    	@IndicatorsSystemVersion archiveIndicatorsSystem(String uuid) throws MetamacException;	    		    	
	    	@IndicatorsSystemVersion versioningIndicatorsSystem(String uuid, @VersionTypeEnum versionType) throws MetamacException;
	    	List<@IndicatorsSystemVersion> retrieveIndicatorsSystemPublishedForIndicator(String indicatorUuid) throws MetamacException;
	    	
	    	// Dimensions
	    	@Dimension createDimension(String indicatorsSystemUuid, @Dimension dimension) throws MetamacException;
	    	@Dimension updateDimension(@Dimension dimension) throws MetamacException;
	    	@Dimension updateDimensionLocation(String uuid, String parentTargetUuid, Long orderInLevel) throws MetamacException;
	    	@Dimension retrieveDimension(String uuid) throws MetamacException;
	    	deleteDimension(String uuid) throws MetamacException;
	    	List<@Dimension> retrieveDimensionsByIndicatorsSystem(String indicatorsSystemUuid, String indicatorsSystemVersionNumber) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystemByDimension(String uuid) throws MetamacException;
	    	
	    	// Indicators instances
	    	@IndicatorInstance createIndicatorInstance(String indicatorsSystemUuid, @IndicatorInstance indicatorInstance) throws MetamacException;
	    	@IndicatorInstance updateIndicatorInstance(@IndicatorInstance indicatorInstance) throws MetamacException;
	    	@IndicatorInstance updateIndicatorInstanceLocation(String uuid, String parentTargetUuid, Long orderInLevel) throws MetamacException;
	    	@IndicatorInstance retrieveIndicatorInstance(String uuid) throws MetamacException;
	    	@IndicatorInstance retrieveIndicatorInstancePublishedByCode(String code) throws MetamacException;
	    	deleteIndicatorInstance(String uuid) throws MetamacException;
	    	PagedResult<@IndicatorInstance> findIndicatorsInstancesInPublishedIndicatorsSystems(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	PagedResult<@IndicatorInstance> findIndicatorsInstancesInLastVersionIndicatorsSystems(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	List<@IndicatorInstance> retrieveIndicatorsInstancesByIndicatorsSystem(String indicatorsSystemUuid, String indicatorsSystemVersionNumber) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystemByIndicatorInstance(String uuid) throws MetamacException;
	    	
	    	// Indicators System History
	    	List<@IndicatorsSystemHistory> findIndicatorsSystemHistory(String uuid, int maxResults) throws MetamacException;
	    	PagedResult<@IndicatorsSystemHistory> findIndicatorsSystemsHistory(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    		    	
	    	// Geographical values
	    	@GeographicalValue retrieveGeographicalValue(String uuid) throws MetamacException;
	    	@GeographicalValue retrieveGeographicalValueByCode(String code) throws MetamacException;
	    	PagedResult<@GeographicalValue> findGeographicalValues(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	@GeographicalValue createGeographicalValue(@GeographicalValue geographicalValue) throws MetamacException;
	    	@GeographicalValue updateGeographicalValue(@GeographicalValue geographicalValue) throws MetamacException;
	    	deleteGeographicalValue(String geographicalValueUuid) throws MetamacException;

	    	// Geographical granularities
	    	@GeographicalGranularity retrieveGeographicalGranularity(String uuid) throws MetamacException;
	    	@GeographicalGranularity retrieveGeographicalGranularityByCode(String code) throws MetamacException;
	    	List<@GeographicalGranularity> retrieveGeographicalGranularities() throws MetamacException;
	    	PagedResult<@GeographicalGranularity> findGeographicalGranularities(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	@GeographicalGranularity createGeographicalGranularity(@GeographicalGranularity geographicalGranularity) throws MetamacException;
	    	@GeographicalGranularity updateGeographicalGranularity(@GeographicalGranularity geographicalGranularity) throws MetamacException;
	    	deleteGeographicalGranularity(String geographicalGranularityUuid) throws MetamacException;
	    	
			// Time values
	    	TimeValue retrieveTimeValue(String timeValue) throws MetamacException;

	    	// Time granularities
	    	List<TimeGranularity> retrieveTimeGranularities() throws MetamacException;
	    	TimeGranularity retrieveTimeGranularity(@IstacTimeGranularityEnum timeGranularity) throws MetamacException;
	    	
	    	// Measure value
	    	MeasureValue retrieveMeasureValue(@MeasureDimensionTypeEnum measureValue) throws MetamacException;
	    	List<MeasureValue> retrieveMeasuresValues(List<String> measureCodes) throws MetamacException;
    	}
    	
    	"Provides access to indicators"
    	Service IndicatorsService {
    		> @IndicatorRepository
    		> @IndicatorVersionRepository
    		> @IndicatorVersionGeoCoverageRepository
    		> @IndicatorVersionTimeCoverageRepository
    		> @IndicatorVersionMeasureCoverageRepository
    		> @DataSourceRepository
    		> @QuantityUnitRepository
    		> @IndicatorInstanceRepository
    		> @IndicatorsDataService
    		> @IndicatorsSystemRepository
    		> @UnitMultiplierRepository
    		> @TaskService
    		
    		// Indicator
    		@IndicatorVersion createIndicator(@IndicatorVersion indicatorVersion) throws MetamacException;
	    	@Indicator retrieveIndicator(String uuid) throws MetamacException;
	    	@IndicatorVersion retrieveIndicator(String uuid, String versionNumber) throws MetamacException;
	    	@IndicatorVersion retrieveIndicatorPublished(String uuid) throws MetamacException;
	    	@IndicatorVersion retrieveIndicatorByCode(String code, String versionNumber) throws MetamacException;
	    	@IndicatorVersion retrieveIndicatorPublishedByCode(String code) throws MetamacException;
	    	@Indicator updateIndicator(@Indicator indicator) throws MetamacException;
	    	@IndicatorVersion updateIndicatorVersion(@IndicatorVersion indicatorVersion) throws MetamacException;
	    	deleteIndicator(String uuid) throws MetamacException;
	    	PagedResult<@IndicatorVersion> findIndicators(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	String exportIndicatorsTsv(List<ConditionalCriteria> conditions) throws MetamacException;
	    	PagedResult<@IndicatorVersion> findIndicatorsPublished(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	@IndicatorVersion sendIndicatorToProductionValidation(String uuid) throws MetamacException;
			@IndicatorVersion rejectIndicatorProductionValidation(String uuid) throws MetamacException;
	    	@IndicatorVersion sendIndicatorToDiffusionValidation(String uuid) throws MetamacException;
	    	@IndicatorVersion rejectIndicatorDiffusionValidation(String uuid) throws MetamacException;
	    	PublishIndicatorResult publishIndicator(String uuid) throws MetamacException;	    		    	
	    	@IndicatorVersion archiveIndicator(String uuid) throws MetamacException;	    		    	
	    	@IndicatorVersion versioningIndicator(String uuid, @VersionTypeEnum versionType) throws MetamacException;
	    	"Mark indicator for not notify population errors"
            disableNotifyPopulationErrors(String indicatorUuid) throws MetamacException;
            "Mark indicator for notify population errors"
            enableNotifyPopulationErrors(String indicatorUuid) throws MetamacException;
	    	
	    	// Data sources
	    	@DataSource createDataSource(String indicatorUuid, @DataSource dataSource) throws MetamacException;
	    	@DataSource updateDataSource(@DataSource dataSource) throws MetamacException;
	    	@DataSource retrieveDataSource(String uuid) throws MetamacException;
	    	deleteDataSource(String uuid) throws MetamacException;
	    	List<@DataSource> retrieveDataSourcesByIndicator(String indicatorUuid, String indicatorVersionNumber) throws MetamacException;
	    	
	    	// Quantity units
	    	@QuantityUnit retrieveQuantityUnit(String uuid) throws MetamacException;
	    	List<@QuantityUnit> retrieveQuantityUnits() throws MetamacException;
	    	PagedResult<@QuantityUnit> findQuantityUnits(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	@QuantityUnit createQuantityUnit(@QuantityUnit quantityUnit) throws MetamacException;
	    	@QuantityUnit updateQuantityUnit(@QuantityUnit quantityUnit) throws MetamacException;
	    	deleteQuantityUnit(String quantityUnitUuid) throws MetamacException;
	    	
	    	// Subjects
	    	Subject retrieveSubject(String code) throws MetamacException;
	    	List<Subject> retrieveSubjects() throws MetamacException;
	    	List<SubjectIndicatorResult> retrieveSubjectsInPublishedIndicators() throws MetamacException;
	    	List<SubjectIndicatorResult> retrieveSubjectsInLastVersionIndicators() throws MetamacException;
	    	
	    	// Units multipliers
	    	@UnitMultiplier retrieveUnitMultiplier(String unitMultiplierUuid) throws MetamacException;
	    	@UnitMultiplier retrieveUnitMultiplier(Integer unitMultiplierValue) throws MetamacException;
	    	List<@UnitMultiplier> retrieveUnitsMultipliers() throws MetamacException;
	    	PagedResult<@UnitMultiplier> findUnitMultipliers(List<ConditionalCriteria> conditions, PagingParameter pagingParameter) throws MetamacException;
	    	@UnitMultiplier createUnitMultiplier(@UnitMultiplier unitMultiplier) throws MetamacException;
	    	@UnitMultiplier updateUnitMultiplier(@UnitMultiplier unitMultiplier) throws MetamacException;
	    	deleteUnitMultiplier(String unitMultiplierUuid) throws MetamacException;
    	}
    	
    	"Provides access to indicators data"
    	Service IndicatorsDataService {
    		> @IndicatorsDataProviderService
    		> @IndicatorsCoverageService
    		> @IndicatorsConfigurationService
    		> @IndicatorsSystemsService
    		> @IndicatorRepository
    		> @IndicatorVersionRepository
    		> @IndicatorInstanceRepository
    		> @IndicatorsSystemVersionRepository
    		> @DataGpeRepository
    		> @GeographicalGranularityRepository
    		> @GeographicalValueRepository
    		> @IndicatorInstanceRepository
    		> @DataSourceRepository
    		> @IndicatorVersionLastValueCacheRepository
    		> @IndicatorInstanceLastValueCacheRepository
	   		> @IndicatorVersionTimeCoverageRepository
        	> @IndicatorVersionMeasureCoverageRepository
        	> @IndicatorVersionGeoCoverageRepository
        	> @TranslationRepository
        	> @TaskService

			"Retrieves all Data definition's operations"
	    	List<String> retrieveDataDefinitionsOperationsCodes() throws MetamacException;
			"Retrieves all Data containing basic info only"
	    	List<@DataDefinition> retrieveDataDefinitions() throws MetamacException;
	    	"Find data By operation code"
	    	List<@DataDefinition> findDataDefinitionsByOperationCode(String operationCode) throws MetamacException;
			"Retrieves Data containing basic info only"
	    	@DataDefinition retrieveDataDefinition(String uuid) throws MetamacException;
	    	"Retrieves the Data's structure info"
	    	DataStructure retrieveDataStructure(String uuid) throws MetamacException;
	    	"Populates a given indicator data"
	    	List<MetamacExceptionItem> populateIndicatorData(String indicatorUuid) throws MetamacException;
	    	"Populates a given indicator data in background"
	    	planifyPopulateIndicatorData(String indicatorUuid) throws MetamacException;
	    	"Populates a given indicator version data"
	    	@Indicator populateIndicatorVersionData(String indicatorUuid, String indicatorVersionNumber) throws MetamacException;
	    	"Deletes a given indicator data"
	    	deleteIndicatorVersionData(String indicatorUuid, String indicatorVersionNumber) throws MetamacException;
	    	"Delete a dataset reposotory"
	    	deleteDatasetRepository(String datasetRepositoryId) throws MetamacException;
	    	"Updates data for all published indicators"
	    	List<@IndicatorVersion> updateIndicatorsDataFromGpe() throws MetamacException;
	    	"Updates data for all published indicators"
            List<@IndicatorVersion> updateIndicatorsDataFromMetamac(org.apache.avro.specific.SpecificRecordBase message) throws MetamacException;  	
	    	"Create a dataset repository definition"
	    	DatasetRepositoryDto createDatasetRepositoryDefinition(String indicatorUuid, String indicatorVersion) throws MetamacException;
	    	"Link a dataset view to the latest version of the indicator"
	    	manageDatabaseViewForLastVersion(IndicatorVersion indicatorVersion) throws MetamacException;
	    	"Delete a dataset view"
	    	deleteDatabaseView(String viewName) throws MetamacException;
	    	"Replace old datasetRepository for the new one"
            IndicatorVersion setDatasetRepositoryDeleteOldOne(IndicatorVersion indicatorVersion, DatasetRepositoryDto datasetRepoDto) throws MetamacException;

	    	//Data finders
	    	"Find Published Indicator's Observations by dimensions"
	    	IndicatorObservationsVO findObservationsInIndicatorPublished(String indicatorUuid, IndicatorsDataFilterVO dataFilter) throws MetamacException;
	    	"Find Last version Indicator's Observations by dimensions"
	    	IndicatorObservationsVO findObservationsInIndicatorLastVersion(String indicatorUuid, IndicatorsDataFilterVO dataFilter) throws MetamacException;
	    	"Find Published Indicator's Extended Observations by dimensions"
	    	IndicatorObservationsExtendedVO findObservationsExtendedByDimensionsInIndicatorPublished(String indicatorUuid, IndicatorsDataFilterVO dataFilter) throws MetamacException;
	    	"Find Last version Indicator's Extended Observations by dimensions"
	    	IndicatorObservationsExtendedVO findObservationsExtendedByDimensionsInIndicatorLastVersion(String indicatorUuid, IndicatorsDataFilterVO dataFilter) throws MetamacException;
	    	"Find Published Indicator Instance's Observations by dimensions"
	    	IndicatorObservationsVO findObservationsInIndicatorInstanceWithPublishedIndicator(String indicatorInstanceUuid, IndicatorsDataFilterVO dataFilter) throws MetamacException;
	    	"Find Last version Indicator Instance's Observations by dimensions"
	    	IndicatorObservationsVO findObservationsInIndicatorInstanceWithLastVersionIndicator(String indicatorInstanceUuid, IndicatorsDataFilterVO dataFilter) throws MetamacException;
	    	"Find Published Indicator Instance's Extended Observations by dimensions"
	    	IndicatorObservationsExtendedVO findObservationsExtendedByDimensionsInIndicatorInstanceWithPublishedIndicator(String indicatorInstanceUuid, IndicatorsDataFilterVO dataFilter) throws MetamacException;
	    	"Find Last version Indicator Instance's Extended Observations by dimensions"
	    	IndicatorObservationsExtendedVO findObservationsExtendedByDimensionsInIndicatorInstanceWithLastVersionIndicator(String indicatorInstanceUuid, IndicatorsDataFilterVO dataFilter) throws MetamacException;
	    	
	    	//Find indicators/indicatorInstance based on code dimensions
	    	List<@IndicatorVersion> findIndicatorsVersionsPublishedWithSubjectCodeAndGeoCodeOrderedByLastUpdate(String subjectCode, String geoCode) throws MetamacException;
			List<IndicatorVersionLastValue> findLastValueNLastIndicatorsVersionsWithSubjectCodeAndGeoCodeOrderedByLastUpdate(String subjectCode, String geoCode, List<@MeasureDimensionTypeEnum> measures, int numResults) throws MetamacException;
			List<IndicatorVersionLastValue> findLastValueForIndicatorsVersionsWithGeoCodeOrderedByLastUpdate(List<String> indicatorsCodes, String geoCode, List<@MeasureDimensionTypeEnum> measures) throws MetamacException;
			
			List<@IndicatorInstance> findIndicatorsInstancesInPublishedIndicatorsSystemWithGeoCodeOrderedByLastUpdate(String systemCode, String geoCode) throws MetamacException;
			List<IndicatorInstanceLastValue> findLastValueNLastIndicatorsInstancesInIndicatorsSystemWithGeoCodeOrderedByLastUpdate(String systemCode, String geoCode, List<@MeasureDimensionTypeEnum> measures, int numResults) throws MetamacException;
			List<IndicatorInstanceLastValue> findLastValueForIndicatorsInstancesWithGeoCodeOrderedByLastUpdate(String systemCode, List<String> indicatorsInstancesCodes, String geoCode, List<@MeasureDimensionTypeEnum> measures) throws MetamacException;
			
			buildIndicatorInstanceLatestValuesCache(@IndicatorInstance indicatorInstance, @IndicatorVersion indicatorVersion) throws MetamacException;
			
			@IndicatorVersion getIndicatorPublishedVersion(String indicatorUuid) throws MetamacException;
    	}
    	
    	"Provides access to indicators coverage"
    	Service IndicatorsCoverageService {
    		> @IndicatorInstanceRepository
    		> @IndicatorVersionRepository
    		> @IndicatorVersionTimeCoverageRepository
        	> @IndicatorVersionMeasureCoverageRepository
        	> @IndicatorVersionGeoCoverageRepository
    		> @IndicatorRepository
    		> @IndicatorsSystemsService

	    	//Geographic Values and granularities related to Indicator data
	    	"Retrieves geographic granularities in the indicator"
	    	List<@GeographicalGranularity> retrieveGeographicalGranularitiesInIndicatorVersion(@IndicatorVersion indicatorVersion) throws MetamacException;
	    	"Retrieves geographic granularities in the indicator instance with published indicator"
	    	List<@GeographicalGranularity> retrieveGeographicalGranularitiesInIndicatorInstanceWithPublishedIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves geographic granularities in the indicator instance with last version indicator"
	    	List<@GeographicalGranularity> retrieveGeographicalGranularitiesInIndicatorInstanceWithLastVersionIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves geographic values with granularity in the indicator"
	    	List<@GeographicalValue> retrieveGeographicalValuesByGranularityInIndicator(String indicatorUuid, String indicatorVersionNumber, String granularityUuid) throws MetamacException;
	    	"Retrieves geographic values in the indicator"
	    	List<GeographicalValueVO> retrieveGeographicalValuesInIndicatorVersion(@IndicatorVersion indicatorVersion) throws MetamacException;
	    	"Retrieves geographic values in the published indicator"
	    	List<GeographicalCodeVO> retrieveGeographicalCodesInIndicatorVersion(@IndicatorVersion indicatorVersion) throws MetamacException;
	    	"Retrieves geographic values in the indicator instance with published indicator"
	    	List<GeographicalValueVO> retrieveGeographicalValuesInIndicatorInstanceWithPublishedIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves geographic values in the indicator instance with last version indicator"
	    	List<GeographicalValueVO> retrieveGeographicalValuesInIndicatorInstanceWithLastVersionIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	
	    	"Retrieves geographic values in the indicator instance with published indicator"
	    	List<GeographicalCodeVO> retrieveGeographicalCodesInIndicatorInstanceWithPublishedIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves geographic values in the indicator instance with last version indicator"
	    	List<GeographicalCodeVO> retrieveGeographicalCodesInIndicatorInstanceWithLastVersionIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves geographic codes in the indicator instance with provided indicator version"
	    	List<GeographicalCodeVO> retrieveGeographicalCodesInIndicatorInstanceWithIndicatorVersion(@IndicatorInstance indicatorInstance, @IndicatorVersion indicatorVersion) throws MetamacException;
	    	"Retrieves geographic codes in the indicator instance with published indicator filtered by granularity"
	    	List<GeographicalCodeVO> retrieveGeographicalCodesByGranularityInIndicatorInstanceWithPublishedIndicator(String indicatorInstanceUuid, String granularityUuid) throws MetamacException;
	    	
	    	"Retrieves geographic granularities in all indicators with a subject Code "
	    	List<@GeographicalGranularity> retrieveGeographicalGranularitiesInIndicatorsPublishedWithSubjectCode(String subjectCode) throws MetamacException;
	    	"Retrieves geographic values in all indicators with a subject Code by granularity"
	    	List<GeographicalValueVO> retrieveGeographicalValuesByGranularityInIndicatorPublishedWithSubjectCode(String subjectCode, String granularityUuid) throws MetamacException;
	    	"Retrieves geographic granularities in all indicators instances in a indicators System"
	    	List<@GeographicalGranularity> retrieveGeographicalGranularitiesInIndicatorsInstanceInPublishedIndicatorsSystem(String systemCode) throws MetamacException;
	    	"Retrieves geographic values in all indicators instances in a published indicators System by granularity"
	    	List<GeographicalValueVO> retrieveGeographicalValuesByGranularityInIndicatorsInstancesInPublishedIndicatorsSystem(String systemCode, String granularityUuid) throws MetamacException;
	    	
	    	//Time Values and granularities related to Indicator data
	    	"Retrieves time granularities in the indicator"
	    	List<TimeGranularity> retrieveTimeGranularitiesInIndicator(String indicatorUuid, String indicatorVersionNumber) throws MetamacException;
	    	"Retrieves time granularities in the published indicator"
	    	List<TimeGranularity> retrieveTimeGranularitiesInIndicatorPublished(String indicatorUuid) throws MetamacException;
	    	"Retrieves time granularities in the indicator instance with published indicator"
	    	List<TimeGranularity> retrieveTimeGranularitiesInIndicatorInstanceWithPublishedIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves time granularities in the indicator instance with last version indicator"
	    	List<TimeGranularity> retrieveTimeGranularitiesInIndicatorInstanceWithLastVersionIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves time values granularities in the indicator"
	    	List<TimeValue> retrieveTimeValuesByGranularityInIndicator(String indicatorUuid, String indicatorVersionNumber, @IstacTimeGranularityEnum granularity) throws MetamacException;
	    	"Retrieves time values granularities in the publidhed indicator"
	    	List<TimeValue> retrieveTimeValuesByGranularityInIndicatorPublished(String indicatorUuid, @IstacTimeGranularityEnum granularity) throws MetamacException;
	    	"Retrieves time values with granularity in the indicator instance"
	    	List<TimeValue> retrieveTimeValuesByGranularityInIndicatorInstance(String indicatorInstanceUuid, @IstacTimeGranularityEnum granularity) throws MetamacException;
	    	"Retrieves time values in the indicator"
	    	List<TimeValue> retrieveTimeValuesInIndicatorVersion(@IndicatorVersion indicatorVersion) throws MetamacException;
	    	"Retrieves time values in the indicator instance with published indicator"
	    	List<TimeValue> retrieveTimeValuesInIndicatorInstanceWithPublishedIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves time values in the indicator instance with last version indicator"
	    	List<TimeValue> retrieveTimeValuesInIndicatorInstanceWithLastVersionIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves time values in the indicator instance with provided indicator version"
	    	List<TimeValue> retrieveTimeValuesInIndicatorInstanceWithIndicatorVersion(@IndicatorInstance indicatorInstance, @IndicatorVersion indicatorVersion) throws MetamacException;
	    	
	    	//Measure values
	    	"Retrieves measure values in indicator version"
	    	List<MeasureValue> retrieveMeasureValuesInIndicatorVersion(@IndicatorVersion indicatorVersion) throws MetamacException;
	    	"Retrieves measure values in indicator instance with published Indicator"
	    	List<MeasureValue> retrieveMeasureValuesInIndicatorInstanceWithPublishedIndicator(String indicatorInstanceUuid) throws MetamacException;
	    	"Retrieves measure values in indicator instance with last versionIndicator"
	    	List<MeasureValue> retrieveMeasureValuesInIndicatorInstanceWithLastVersionIndicator(String indicatorInstanceUuid) throws MetamacException;
    	}
    	
    	
    	"Provides access to indicators data from Jaxi"
    	Service IndicatorsDataProviderService {
    		"Retrieves the Data's structure info"
		    String retrieveDataStructureJson(String uuid) throws MetamacException;
	     	"Retrieves Data content"
    		String retrieveDataJson(String uuid) throws MetamacException;
    	}
    	
    	"Provides access to indicators data from Jaxi"
    	Service IndicatorsConfigurationService {
    		> @ConfigurationRepository
    		"Retrieves last successful query date to Gpe"
		    DateTimestamp retrieveLastSuccessfulGpeQueryDate() throws MetamacException;
		    setLastSuccessfulGpeQueryDate(DateTimestamp date) throws MetamacException;
    	}
    	
    	"Provides access to indicators data from Jaxi"
    	Service DsplExporterService {
    		> @IndicatorsSystemsService
    		> @IndicatorsDataService
    		> @IndicatorsCoverageService
    		> @IndicatorsService
    		
    		"Export Indicators System as a DSPL zip file"
		    List<String> exportIndicatorsSystemPublishedToDsplFiles(String indicatorsSystemUuid, @InternationalString title, @InternationalString description, boolean mergeTimeGranularities) throws MetamacException;
    	}
    				    
    	"Provides access to indicators, indicators systems..."
    	Service IndicatorsServiceFacade {
			> @IndicatorsSystemsService
			> @DsplExporterService
    		> @IndicatorsService
    		> @IndicatorsDataService
    		> @IndicatorsCoverageService
	    	
	    	// INDICATORS SYSTEMS
	    	"Creates an indicators system"
	    	@IndicatorsSystemDto createIndicatorsSystem(@IndicatorsSystemDto indicatorsSystemDto) throws MetamacException;
	    	"Retrieves an indicators system by code. If versionNumber is not provided, retrieves last version"
	    	@IndicatorsSystemDto retrieveIndicatorsSystemByCode(String code, String versionNumber) throws MetamacException;
	    	
	    	
	    	"Deletes a version of an indicators system. Version to remove must be not published nor archived"
	    	deleteIndicatorsSystem(String uuid) throws MetamacException;
	    	"Sends indicators system to production validation"
	    	@IndicatorsSystemDto sendIndicatorsSystemToProductionValidation(String uuid) throws MetamacException;
	    	"Rejects production validation of indicators system"
	    	@IndicatorsSystemDto rejectIndicatorsSystemProductionValidation(String uuid) throws MetamacException;
	    	"Sends indicators system to diffusion validation"
	    	@IndicatorsSystemDto sendIndicatorsSystemToDiffusionValidation(String uuid) throws MetamacException;
	    	"Rejects diffusion validation of indicators system"
	    	@IndicatorsSystemDto rejectIndicatorsSystemDiffusionValidation(String uuid) throws MetamacException;
	    	"Publishes indicators system"
	    	@IndicatorsSystemDto publishIndicatorsSystem(String uuid) throws MetamacException;	    		    	
	    	"Archives indicators system"
	    	@IndicatorsSystemDto archiveIndicatorsSystem(String uuid) throws MetamacException;	    		    	
	    	"Creates a version on draft of an indicators system in diffusion. Returns new version created"
	    	@IndicatorsSystemDto versioningIndicatorsSystem(String uuid, @VersionTypeEnum versionType) throws MetamacException;
	    	"Finds indicators systems by criteria in any state, returning last versions"
	    	MetamacCriteriaResult<@IndicatorsSystemSummaryDto> findIndicatorsSystems(MetamacCriteria criteria) throws MetamacException;
	    	"Retrieves indicators system structure: dimensions and indicators instances by levels. If versionNumber is not provided, retrieves last version"
	    	@IndicatorsSystemStructureDto retrieveIndicatorsSystemStructure(String uuid, String versionNumber) throws MetamacException;
	    	"Export a published Indicators System as a set of dspl zip files"
	    	List<String> exportIndicatorsSystemPublishedToDsplFiles(String indicatorsSystemUuid, @InternationalStringDto title, @InternationalStringDto description, boolean mergeTimeGranularities) throws MetamacException;
	    	
	    	
	    	
	    	// DIMENSIONS
	    	"Creates a dimension"
	    	@DimensionDto createDimension(String indicatorsSystemUuid, @DimensionDto dimensionDto) throws MetamacException;
	    	"Updates metadata of dimension"
	    	@DimensionDto updateDimension(@DimensionDto dimensionDto) throws MetamacException;
	    	"Updates the location of dimension"
	    	@DimensionDto updateDimensionLocation(String uuid, String parentTargetUuid, Long orderInLevel) throws MetamacException;
	    	"Retrieves dimension"
	    	@DimensionDto retrieveDimension(String uuid) throws MetamacException;
	    	"Deletes dimension"
	    	deleteDimension(String uuid) throws MetamacException;
	    	
	    	// INDICATORS INSTANCES	    	
	    	"Creates a indicator instance"
	    	@IndicatorInstanceDto createIndicatorInstance(String indicatorsSystemUuid, @IndicatorInstanceDto indicatorInstanceDto) throws MetamacException;
	    	"Updates metadata of indicator instance"
	    	@IndicatorInstanceDto updateIndicatorInstance(@IndicatorInstanceDto indicatorInstanceDto) throws MetamacException;
	    	"Updates the location of indicator instance"
	    	@IndicatorInstanceDto updateIndicatorInstanceLocation(String uuid, String parentTargetUuid, Long orderInLevel) throws MetamacException;
	    	"Retrieves indicator instance"
	    	@IndicatorInstanceDto retrieveIndicatorInstance(String uuid) throws MetamacException;
	    	"Deletes indicator instance"
	    	deleteIndicatorInstance(String uuid) throws MetamacException;

	    	// GEOGRAPHICAL VALUES
	    	"Retrieves geographical value"
	    	@GeographicalValueDto retrieveGeographicalValue(String uuid) throws MetamacException;
	    	"Find geographical values by criteria"
	    	MetamacCriteriaResult<@GeographicalValueDto> findGeographicalValues(MetamacCriteria criteria) throws MetamacException;
	    	"Retrieves geographic values with granularity in the indicator"
	    	List<@GeographicalValueDto> retrieveGeographicalValuesByGranularityInIndicator(String indicatorUuid, String indicatorVersionNumber, String granularityUuid) throws MetamacException;
	    	"Create a geographical value"
	    	@GeographicalValueDto createGeographicalValue(@GeographicalValueDto geographicalValueDto) throws MetamacException;
	    	"Update a geographical value"
	    	@GeographicalValueDto updateGeographicalValue(@GeographicalValueDto geographicalValueDto) throws MetamacException;
	    	"Delete a geographical value"
	    	deleteGeographicalValue(String uuid) throws MetamacException;
	    	
	    	// GEOGRAPHICAL GRANULARITIES
	    	"Retrieves geographical granularity"
	    	@GeographicalGranularityDto retrieveGeographicalGranularity(String uuid) throws MetamacException;
	    	"Find geographical granularities by criteria"
	    	MetamacCriteriaResult<@GeographicalGranularityDto> findGeographicalGranularities(MetamacCriteria criteria) throws MetamacException;
	    	"Retrieves all geographical granularities"
	    	List<@GeographicalGranularityDto> retrieveGeographicalGranularities() throws MetamacException;
	    	"Retrieves geographic granularities in the indicator"
	    	List<@GeographicalGranularityDto> retrieveGeographicalGranularitiesInIndicator(String indicatorUuid, String indicatorVersionNumber) throws MetamacException;
	    	"Create a geographical granularity"
	    	@GeographicalGranularityDto createGeographicalGranularity(@GeographicalGranularityDto geographicalGranularityDto) throws MetamacException;
	    	"Update a geographical granularity"
	    	@GeographicalGranularityDto updateGeographicalGranularity(@GeographicalGranularityDto geographicalGranularityDto) throws MetamacException;
	    	"Delete a geographical granularity"
	    	deleteGeographicalGranularity(String uuid) throws MetamacException;
	    	
	    	// TIME GRANULARITIES
	    	"Retrieves time granularities in the indicator"
	    	List<@TimeGranularityDto> retrieveTimeGranularitiesInIndicator(String indicatorUuid, String indicatorVersionNumber) throws MetamacException;
	    	
	    	// TIME VALUES
	    	"Retrieves time values granularities in the indicator"
	    	List<@TimeValueDto> retrieveTimeValuesByGranularityInIndicator(String indicatorUuid, String indicatorVersionNumber, @IstacTimeGranularityEnum granularity) throws MetamacException;

	    	// INDICATORS
	    	"Creates an indicator"
	    	@IndicatorDto createIndicator(@IndicatorDto indicatorDto) throws MetamacException;
	    	"Updates metadata of an indicator. This version can not be published or archived"
	    	@IndicatorDto updateIndicator(@IndicatorDto indicatorDto) throws MetamacException;
	    	"Retrieves an indicator. If versionNumber is not provided, retrieves last version"
	    	@IndicatorDto retrieveIndicator(String uuid, String versionNumber) throws MetamacException;
	    	"Retrieves an indicator by code. If versionNumber is not provided, retrieves last version"
	    	@IndicatorDto retrieveIndicatorByCode(String code, String versionNumber) throws MetamacException;
	    	"Deletes a version of an indicator. Version to remove must be not published nor archived"
	    	deleteIndicator(String uuid) throws MetamacException;
	    	"Sends indicator to production validation"
	    	@IndicatorDto sendIndicatorToProductionValidation(String uuid) throws MetamacException;
	    	"Rejects production validation of indicator"
	    	@IndicatorDto rejectIndicatorProductionValidation(String uuid) throws MetamacException;
	    	"Sends indicator to diffusion validation"
	    	@IndicatorDto sendIndicatorToDiffusionValidation(String uuid) throws MetamacException;
	    	"Rejects diffusion validation of indicator"
	    	@IndicatorDto rejectIndicatorDiffusionValidation(String uuid) throws MetamacException;
	    	"Publishes indicator"
	    	@PublishIndicatorResultDto publishIndicator(String uuid) throws MetamacException;	    		    	
	    	"Archives indicator"
	    	@IndicatorDto archiveIndicator(String uuid) throws MetamacException;	    		    	
	    	"Creates a version on draft of an indicator in diffusion. Returns new version created"
	    	@IndicatorDto versioningIndicator(String uuid, @VersionTypeEnum versionType) throws MetamacException;
	    	"Finds indicators by criteria in any state, returning last versions"
	    	MetamacCriteriaResult<@IndicatorSummaryDto> findIndicators(MetamacCriteria criteria) throws MetamacException;
	    	"Mark indicator for not notif population errors"
	    	disableNotifyPopulationErrors(String indicatorUuid) throws MetamacException;
	    	"Mark indicator for not notif population errors"
            enableNotifyPopulationErrors(String indicatorUuid) throws MetamacException;
	    	"Export indicators list in TSV format"
	    	String exportIndicatorsTsv(MetamacCriteria criteria) throws MetamacException;
	    	
	    	// DATASOURCES
	    	"Creates a data source"
	    	@DataSourceDto createDataSource(String indicatorUuid, @DataSourceDto dataSourceDto) throws MetamacException;
	    	"Updates metadata of data source"
	    	@DataSourceDto updateDataSource(@DataSourceDto dataSourceDto) throws MetamacException;
	    	"Retrieves data source"
	    	@DataSourceDto retrieveDataSource(String uuid) throws MetamacException;
	    	"Deletes data source"
	    	deleteDataSource(String uuid) throws MetamacException;
	    	"Retrieves all data sources of indicator"
	    	List<@DataSourceDto> retrieveDataSourcesByIndicator(String indicatorUuid, String indicatorVersionNumber) throws MetamacException;
	    	
	    	// QUANTITY UNITS
	    	"Find quantity units by criteria"
	    	MetamacCriteriaResult<@QuantityUnitDto> findQuantityUnits(MetamacCriteria criteria) throws MetamacException;
	    	"Retrieve all quantity units"
	    	List<@QuantityUnitDto> retrieveQuantityUnits() throws MetamacException;
	    	"Create a quantity unit"
	    	@QuantityUnitDto createQuantityUnit(@QuantityUnitDto quantityUnitDto) throws MetamacException;
	    	"Update a quantity unit"
	    	@QuantityUnitDto updateQuantityUnit(@QuantityUnitDto quantityUnitDto) throws MetamacException;
	    	"Delete a quantity unit"
	    	deleteQuantityUnit(String uuid) throws MetamacException;
	    	
			// SUBJECTS
	    	"Retrieves all subjects. Important! Do not invoke this operation from public web application"
	    	List<@SubjectDto> retrieveSubjects() throws MetamacException;
	    	
	    	// DATA
	    	"Retrieves all Data definition's operations"
	    	List<String> retrieveDataDefinitionsOperationsCodes() throws MetamacException;
	    	"Retrieves all Data containing basic info only"
	    	List<@DataDefinitionDto> retrieveDataDefinitions() throws MetamacException;
	    	"Find data By operation code"
	    	List<@DataDefinitionDto> findDataDefinitionsByOperationCode(String operationCode) throws MetamacException;
	    	"Retrieves all Data basic info only"
	    	@DataDefinitionDto retrieveDataDefinition(String uuid) throws MetamacException;
	    	"Retrieves the Data's structure info"
	    	@DataStructureDto retrieveDataStructure(String uuid) throws MetamacException;
	    	// "Populates a given indicator data"
	    	// List<MetamacExceptionItem> populateIndicatorData(String indicatorUuid) throws MetamacException;
	        "Populates a given indicator data in background"
	    	planifyPopulateIndicatorData(String indicatorUuid) throws MetamacException;
	    	"Update indicators data GPE"
	    	List<@IndicatorVersion> updateIndicatorsDataFromGpe() throws MetamacException;
	    	"Update indicators data METAMAC"
	    	List<@IndicatorVersion> updateIndicatorsDataFromMetamac(org.apache.avro.specific.SpecificRecordBase message) throws MetamacException;    
	    	
	    	// UNITS MULTIPLIERS
	    	"Retrieves all units multipliers"
	    	List<@UnitMultiplierDto> retrieveUnitsMultipliers() throws MetamacException;
	    	"Find unit multipliers by criteria"
	    	MetamacCriteriaResult<@UnitMultiplierDto> findUnitMultipliers(MetamacCriteria criteria) throws MetamacException;
	    	"Create a unit multiplier"
	    	@UnitMultiplierDto createUnitMultiplier(@UnitMultiplierDto unitMultiplierDto) throws MetamacException;
	    	"Update a unit multiplier"
	    	@UnitMultiplierDto updateUnitMultiplier(@UnitMultiplierDto unitMultiplierDto) throws MetamacException;
	    	"Delete a unit multiplier"
	    	deleteUnitMultiplier(String unitMultiplierUuid) throws MetamacException;
	    	
	    }

	    // ----------------------------------------------------------------
		// 							ENTITIES
		// ----------------------------------------------------------------        	
		"Indicators system entity"
		Entity IndicatorsSystem {
			databaseTable="TB_INDICATORS_SYSTEMS"
			hint="idSequence=INDICATORS_SYSTEMS"
			gap
			
			"Semantic identifier of statistic operation. Non modifiable"
       		String code not nullable;
		
			// Can not do an OneToOne relation with IndicatorsSystemVersion because this produces a CyclicDependency with IndicatorsSystem
			"Version in production"
            - @IndicatorsSystemVersionInformation productionVersion nullable databaseColumn="PRODUCTION";
            "Version in diffusion"
            - @IndicatorsSystemVersionInformation diffusionVersion nullable databaseColumn="DIFFUSION";
            "True if indicator system is published"
            Boolean isPublished not nullable;
			"All versions"
			- Bag<@IndicatorsSystemVersion> versions cascade="all-delete-orphan" fetch="lazy" inverse <-> indicatorsSystem orderby="versionNumber asc";
			
			Repository IndicatorsSystemRepository {
		   		@IndicatorsSystem save(@IndicatorsSystem entity);
		   		delete;
            	protected List<@IndicatorsSystem> findByQuery;
            	protected List<@IndicatorsSystem> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@IndicatorsSystem retrieveIndicatorsSystem(String uuid);
            	findByCondition(PagingParameter pagingParameter);
			}
		} 
		
		"Indicators system entity"
		Entity IndicatorsSystemHistory {
			databaseTable="TB_INDICATORS_SYSTEMS_HIST"
			hint="idSequence=INDICATORS_SYSTEMS_HIST"
			!auditable
        	!optimisticLocking
        	gap
			
            - @IndicatorsSystem indicatorsSystem key not nullable databaseColumn="INDICATORS_SYSTEM_FK";
            String versionNumber key not nullable; 
            "Date when the indicators system version was published"
			DateTimeTZ publicationDate not nullable;
			
			Repository IndicatorsSystemHistoryRepository {
		   		@IndicatorsSystemHistory save(@IndicatorsSystemHistory entity);
		   		delete;
            	findByCondition(PagingParameter pagingParameter);
            	protected List<@IndicatorsSystemHistory> findByQuery;
            	protected List<@IndicatorsSystemHistory> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	List<@IndicatorsSystemHistory> findIndicatorsSystemHistory(String uuid, int maxResults);
			}
		} 
		
		"Version of indicators system entity"
		Entity IndicatorsSystemVersion {
			databaseTable="TB_INDIC_SYSTEMS_VERSIONS"
			hint="idSequence=INDIC_SYSTEMS_VERSIONS"
			gap
			
			"Processing status"
			- @IndicatorsSystemProcStatusEnum procStatus not nullable;
			String versionNumber not nullable length="10";
       		"True if this version is the last"
       		Boolean isLastVersion not nullable;
       		
			"Date when the indicators system was sended to production validation"
			DateTimeTZ productionValidationDate nullable;
			"User who sended to production validation"
			String productionValidationUser nullable;
			"Date when the indicators system was sended to diffusion validation"
			DateTimeTZ diffusionValidationDate nullable;
			"User who sended to diffusion validation"
			String diffusionValidationUser nullable;
			"Date when the indicators system was published"
			DateTimeTZ publicationDate nullable;
			"User who published"
			String publicationUser nullable;
			"Date when the indicators system was archived"
			DateTimeTZ archiveDate nullable;
			"User who archived"
			String archiveUser nullable;

			// Relations
			"Indicator system"
			- @IndicatorsSystem indicatorsSystem not nullable cascade="none" databaseColumn="INDICATORS_SYSTEM_FK" <-> versions;
			"Association to all elements in the indicators system"
			- Bag<@ElementLevel> childrenAllLevels cascade="all-delete-orphan" fetch="lazy" inverse orderby="parent asc, orderInLevel asc" <-> indicatorsSystemVersion;
			"Association to elements in first level in the indicators system"
			- Bag<@ElementLevel> childrenFirstLevel cascade="all-delete-orphan" fetch="lazy" inverse orderby="orderInLevel asc" <-> indicatorsSystemVersionFirstLevel;
		
			Repository IndicatorsSystemVersionRepository {
				@IndicatorsSystemVersion save(@IndicatorsSystemVersion entity);
				delete;
            	protected List<@IndicatorsSystemVersion> findByQuery;
            	protected List<@IndicatorsSystemVersion> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@IndicatorsSystemVersion retrieveIndicatorsSystemVersion(String uuid, String versionNumber);
            	findByCondition(PagingParameter pagingParameter);
            	List<@IndicatorsSystemVersion> retrieveIndicatorsSystemPublishedForIndicator(String indicatorUuid) throws MetamacException;
			}
		} 
			    
		"Level at indicators system"
        Entity ElementLevel {
        	databaseTable = "TB_ELEMENTS_LEVELS"
        	hint="idSequence=ELEMENTS_LEVELS"
        	gap
        	!auditable
        	
            "Order in level"
			Long orderInLevel not nullable;
			
			// Relations
			"Children"
			- Bag<@ElementLevel> children cascade="all-delete-orphan" inverse orderby="orderInLevel asc" <-> parent;
            "Parent"
            - @ElementLevel parent cascade="none" databaseColumn="PARENT_FK" nullable <-> children;
			"Dimension"
			- @Dimension dimension cascade="all" nullable databaseColumn="DIMENSION_FK" <-> elementLevel;
			"Indicator instance"
			- @IndicatorInstance indicatorInstance cascade="all" nullable databaseColumn="INDICATOR_INSTANCE_FK" <-> elementLevel;
            "Relation to Indicators system to all items, regardless of the level"
			- @IndicatorsSystemVersion indicatorsSystemVersion cascade="none" fetch="lazy" not nullable databaseColumn="IND_SYSTEM_VERSION_ALL_FK" <-> childrenAllLevels;
			"Relation to Indicators system, only filled for items in first level"
			- @IndicatorsSystemVersion indicatorsSystemVersionFirstLevel cascade="none" fetch="lazy" nullable databaseColumn="IND_SYSTEM_VERSION_FIRST_FK" <-> childrenFirstLevel;
			
			"Provides access to ElementLevel"
            Repository ElementLevelRepository {
            	@ElementLevel save(@ElementLevel entity);
            	delete;
            }
        }  		
		
        "Dimension of indicators system"
        Entity Dimension {
        	databaseTable = "TB_DIMENSIONS"
        	hint="idSequence=DIMENSIONS"
        	
            "Title"
            - @InternationalString title cascade="all" not nullable databaseColumn="TITLE_FK";
			"Last update to optimistic locking"
			DateTimeTZ updateDate nullable;

			// Relations
            "Element level"
            - @ElementLevel elementLevel cascade="none" not nullable inverse <-> dimension;
			            
			"Provides access to Dimension"
            Repository DimensionRepository {
            	@Dimension save(@Dimension entity);
            	protected List<@Dimension> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@Dimension findDimension(String uuid);
            }
        }  		
        
		"Instance of indicator"
        Entity IndicatorInstance {
        	databaseTable = "TB_INDICATORS_INSTANCES"
        	hint="idSequence=INDICATORS_INSTANCES"
			gap

			"Code to indicator instance. Not unique (its duplicated when indicators system is versioned). Non modifiable"
       		String code not nullable;
			"Title"
       		- @InternationalString title cascade="all" not nullable databaseColumn="TITLE_FK";
        	"Time granularity"
        	- @IstacTimeGranularityEnum timeGranularity nullable;
        	"Time value"
        	Clob timeValues nullable;
			"Last update to optimistic locking"
			DateTimeTZ updateDate nullable;
			"Date when the indicator instance was populated for the last time"
			DateTimeTZ lastPopulateDate nullable;

			// Relations
			"Last value cache"
			- Set<@IndicatorInstanceLastValueCache> lastValuesCache cascade="delete-orphan" fetch="lazy" inverse <-> indicatorInstance;
            "Element level"
            - @ElementLevel elementLevel cascade="none" not nullable inverse <-> indicatorInstance;
        	"Indicator"
			- @Indicator indicator cascade="none" not nullable databaseColumn="INDICATOR_FK" <-> indicatorsInstances;
            "Geographical granularity"
			- @GeographicalGranularity geographicalGranularity cascade="none" nullable databaseColumn="GEOGRAPHICAL_GRANULARITY_FK";
            "Geographical value"
			- Bag<@GeographicalValue> geographicalValues cascade="none" fetch="lazy" databaseJoinTable="TB_INDIC_INST_GEO_VALUES" databaseColumn="GEOGRAPHICAL_VALUE_FK" databaseJoinColumn="INDICATOR_INSTANCE_FK" orderby="order asc";
            
			"Provides access to IndicatorInstance"
            Repository IndicatorInstanceRepository {
            	@IndicatorInstance save(@IndicatorInstance entity);
            	protected List<@IndicatorInstance> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@IndicatorInstance findIndicatorInstance(String uuid);
            	@IndicatorInstance findIndicatorInstancePublishedByCode(String code);
            	Boolean existAnyIndicatorInstance(String indicatorsSystemUuid, String indicatorsSystemVersionNumber);
            	findByCondition(PagingParameter pagingParameter);
            	List<String> findIndicatorsLinkedWithIndicatorsSystemVersion(Long indicatorsSystemVersionId);
            	List<String> findIndicatorsSystemsPublishedWithIndicator(String indicatorUuid);
            	List<String> findIndicatorsInstancesInPublishedIndicatorSystemWithIndicator(String indicatorUuid);
            	@IndicatorInstance findIndicatorInstanceInPublishedIndicatorSystem(String systemCode, String indicatorInstanceCode);
            	List<@IndicatorInstance> findIndicatorsInstancesInPublishedIndicatorSystem(String systemCode);
            }
        }         
		
        BasicType IndicatorsSystemVersionInformation {
        	gap
        	"Id into database of IndicatorsSystemVersion"
    		Long idIndicatorsSystemVersion nullable databaseColumn="ID";
    		"Version number of IndicatorsSystemVersion"
    		String versionNumber nullable databaseColumn="VERSION_NUMBER" length="10";
    	}	
    	
		"Indicator entity"
		Entity Indicator {
			databaseTable="TB_INDICATORS"
			hint="idSequence=INDICATORS"
			gap

			"Code. Non modifiable"
			String code not nullable;
			"Code for dataset Oracle view"
			String viewCode not nullable length="30";
			
            "Id into database of IndicatorVersion in production environment"
    		Long productionIdIndicatorVersion nullable databaseColumn="PRODUCTION_ID";
    		"Version number of IndicatorVersion in production environment"
    		String productionVersionNumber nullable databaseColumn="PRODUCTION_VERSION_NUMBER" length="10";
            "ProcStatus of IndicatorVersion in production enviroment"
            - @IndicatorProcStatusEnum productionProcStatus nullable databaseColumn="PRODUCTION_PROC_STATUS";
            
			"Id into database of IndicatorVersion in diffusion environment"
    		Long diffusionIdIndicatorVersion nullable databaseColumn="DIFFUSION_ID";
    		"Version number of IndicatorVersion in diffusion environment"
    		String diffusionVersionNumber nullable databaseColumn="DIFFUSION_VERSION_NUMBER" length="10";
            "ProcStatus of IndicatorVersion in diffusion enviroment"
            - @IndicatorProcStatusEnum diffusionProcStatus nullable databaseColumn="DIFFUSION_PROC_STATUS";

            "True if indicator is published"
            Boolean isPublished not nullable;
			"All versions"
			- Bag<@IndicatorVersion> versions cascade="all-delete-orphan" fetch="lazy" inverse <-> indicator orderby="versionNumber asc";
			"Indicator instances"
			- Bag<@IndicatorInstance> indicatorsInstances cascade="none" fetch="lazy" inverse <-> indicator;
			
			"True if user decied to receive notifications when data population fail in this indicator"
			Boolean notifyPopulationErrors not nullable;
			
			Repository IndicatorRepository {
		   		@Indicator save(@Indicator entity);
		   		delete;
            	protected List<@Indicator> findByQuery;
            	protected List<@Indicator> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@Indicator retrieveIndicator(String uuid);
            	findByCondition(PagingParameter pagingParameter);
            	List<String> filterIndicatorsNotPublished(List<String> indicatorsUuid);
			}
		}
	    
		"Version of indicator entity"
		Entity IndicatorVersion {
			databaseTable="TB_INDICATORS_VERSIONS"
			hint="idSequence=INDICATORS_VERSIONS"
			gap
			
			"Processing status"
			- @IndicatorProcStatusEnum procStatus not nullable;
			String versionNumber not nullable length="10";
       		"Title"
       		- @InternationalString title cascade="all" not nullable databaseColumn="TITLE_FK";
       		"Acronym"
       		- @InternationalString acronym cascade="all" nullable databaseColumn="ACRONYM_FK";
       		"Subject code"
			String subjectCode not nullable;
       		"Subject title"
       		- @InternationalString subjectTitle cascade="all" not nullable databaseColumn="SUBJECT_TITLE_FK";
       		"Concept associated with the indicator"
       		- @InternationalString conceptDescription cascade="all" nullable databaseColumn="CONCEPT_DESCRIPTION_FK";
			"Comments"
       		- @InternationalString comments cascade="all" nullable databaseColumn="COMMENTS_FK";
			"Notes"
       		- @InternationalString notes cascade="all" nullable databaseColumn="NOTES_FK";
       		"True if this version is the last"
       		Boolean isLastVersion not nullable;
       		"Identifier in repository of observations"
       		String dataRepositoryId nullable;       		
       		"Table name in repository of observations"
       		String dataRepositoryTableName nullable;
       		"True if indicator needs to be updated"
            Boolean needsUpdate not nullable;  		
       		
			"Date when the indicator was sended to production validation"
			DateTimeTZ productionValidationDate nullable;
			"User who sended to production validation"
			String productionValidationUser nullable;
			"Date when the indicator was sended to diffusion validation"
			DateTimeTZ diffusionValidationDate nullable;
			"User who sended to diffusion validation"
			String diffusionValidationUser nullable;
			"Date when the indicator was published"
			DateTimeTZ publicationDate nullable;
			"User who published"
			String publicationUser nullable;
			"Date when the indicator was supposed to be published but failed"
			DateTimeTZ publicationFailedDate nullable;
			"User when the indicator was supposed to be published but failed"
			String publicationFailedUser nullable;
			"Date when the indicator was archived"
			DateTimeTZ archiveDate nullable;
			"User who archived"
			String archiveUser nullable;
			"Last update to optimistic locking"
			DateTimeTZ updateDate nullable;
			"Date when the indicator was populated for the last time"
			DateTimeTZ lastPopulateDate nullable;
					
			// Relations
			"Last value cache"
			- Set<@IndicatorVersionLastValueCache> lastValuesCache cascade="delete-orphan" fetch="lazy" inverse <-> indicatorVersion;
			"Indicator"
			- @Indicator indicator not nullable cascade="none" databaseColumn="INDICATOR_FK" <-> versions;
			"Quantity"
			- @Quantity quantity not nullable cascade="all" databaseColumn="QUANTITY_FK";
			"Data sources"
			- Bag<@DataSource> dataSources cascade="all-delete-orphan" fetch="lazy" inverse orderby="id asc" <-> indicatorVersion;
		
			Repository IndicatorVersionRepository {
				@IndicatorVersion save(@IndicatorVersion entity);
				delete;
            	protected List<@IndicatorVersion> findByQuery;
            	protected List<@IndicatorVersion> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@IndicatorVersion retrieveIndicatorVersion(String uuid, String versionNumber);
            	@IndicatorVersion findPublishedIndicatorVersionByCode(String indicatorCode);
            	findByCondition(PagingParameter pagingParameter);
            	@IndicatorVersion findOneIndicatorVersionLinkedToIndicator(String indicatorUuid);
            	List<@IndicatorVersion> findIndicatorsVersionNeedsUpdate() throws MetamacException;
            	List<@IndicatorVersion> findIndicatorsVersionLinkedToAnyDataGpeUuids(List<String> dataGpeUuids) throws MetamacException;
            	"Find all distinct subjects in published indicators"
            	List<SubjectIndicatorResult> findSubjectsInPublishedIndicators() throws MetamacException;
            	List<SubjectIndicatorResult> findSubjectsInLastVersionIndicators() throws MetamacException;
            	"Find all distinct subjects in published indicators"
            	List<@IndicatorVersion> findPublishedIndicatorVersionWithSubjectCode(String subjectCode) throws MetamacException;
			}
		}     	
		
	    "Metric characteristics of the indicator"
	    Entity Quantity {
        	databaseTable = "TB_QUANTITIES"
        	hint="idSequence=QUANTITIES"
        	gap

	    	"Type"
			- @QuantityTypeEnum quantityType nullable;
			"Multiplier of percentage"
			- @UnitMultiplier unitMultiplier required cascade="none" databaseColumn="UNIT_MULTIPLIER_FK";
			"Number of significant digits to use when displaying the values of a metric concept"
			Integer significantDigits nullable;
			"Number of decimal places to use for displaying the values of a metric concept"
			Integer decimalPlaces nullable;
			"Min"
			Integer minimum nullable;
			"Max"
			Integer maximum nullable;
			"When Quantity is Ratio, true if is a percentage"
			Boolean isPercentage nullable;
			"In percentages, descriptive text to display next to number that specifies what this is a percentage of"
			- @InternationalString percentageOf cascade="all" nullable databaseColumn="PERCENTAGE_OF_FK";
			"Value base"
			Integer baseValue nullable;
			"Time value base"
			String baseTime nullable;
			
			// Relations
			"Unit"
			- @QuantityUnit unit nullable cascade="none" databaseColumn="UNIT_FK";
			"Numerator of the fraction"
			- @Indicator numerator nullable cascade="none" databaseColumn="NUMERATOR_FK";
			"Denominator of the fraction"
			- @Indicator denominator nullable cascade="none" databaseColumn="DENOMINATOR_FK";
			"Base quantity"
			- @Indicator baseQuantity nullable cascade="none" databaseColumn="BASE_QUANTITY_FK";
            "Geographical value base"
			- @GeographicalValue baseLocation nullable cascade="none" databaseColumn="BASE_LOCATION_FK";
	    }
	    
	    "Metric characteristics of a data source of indicator"
	    Entity RateDerivation {
        	databaseTable = "TB_RATES_DERIVATIONS"
        	hint="idSequence=RATES_DERIVATIONS"
        	
        	gap

	    	"Method type"
			- @RateDerivationMethodTypeEnum methodType not nullable;
			"Method"
			String method not nullable;
			"Rounding"
			- @RateDerivationRoundingEnum rounding nullable;

			// Relations
			"Quantity"
			- @Quantity quantity not nullable cascade="all" databaseColumn="QUANTITY_FK";
			
			"Provides access to RateDerivation"
            Repository RateDerivationRepository {
            	delete;
            }
	    }

		"Data source of indicator"
        Entity DataSource {
        	databaseTable = "TB_DATA_SOURCES"
        	hint="idSequence=DATA_SOURCES"
        	
        	gap
        	
			"Query in GPE"
			String queryUuid not nullable databaseColumn="QUERY_UUID";
			"Px"
			String queryUrn not nullable databaseColumn="QUERY_URN";
			"Time variable"
			String timeVariable nullable;
        	"Time value"
        	String timeValue nullable;
			"Geographical variable"
			String geographicalVariable nullable;
			"Other variables fixing one category"
			- Bag<@DataSourceVariable> otherVariables cascade="all-delete-orphan" fetch="lazy" inverse orderby="id asc" databaseColumn="DATA_SOURCE_FK";
			"Absolute method"
			String absoluteMethod nullable;
			"Source survey code"
			String sourceSurveyCode not nullable;
			"Source survey title"
			- @InternationalString sourceSurveyTitle cascade="all" not nullable databaseColumn="SOURCE_SURVEY_TITLE_FK";
			"Source survey acronym"
			- @InternationalString sourceSurveyAcronym cascade="all" nullable databaseColumn="SOURCE_SURVEY_ACRONYM_FK";
			"Source survey url"
			String sourceSurveyUrl nullable length="4000";
			"Publishers (with ## as separator)"
			String publishers not nullable length="4000";
			"Query Environment"
            - @QueryEnvironmentEnum queryEnvironment not nullable;
			"Structural Resource Code (Metamac) related with the data source"
            - @ExternalItem statResource nullable cascade="all" databaseColumn="STAT_RESOURCE_FK";
             		
			"Last update to optimistic locking"
			DateTimeTZ updateDate nullable;
						
			// Relations
            "Indicator version"
			- @IndicatorVersion indicatorVersion cascade="none" fetch="lazy" nullable databaseColumn="INDICATOR_VERSION_FK" <-> dataSources;
            "Annual puntual rate"
			- @RateDerivation annualPuntualRate nullable cascade="all" databaseColumn="ANNUAL_PUNTUAL_RATE_FK";
            "Annual percentage rate"
			- @RateDerivation annualPercentageRate nullable cascade="all" databaseColumn="ANNUAL_PERCENTAGE_RATE_FK";
            "Interperiod puntual rate"
			- @RateDerivation interperiodPuntualRate nullable cascade="all" databaseColumn="INTERPERIOD_PUNTUAL_RATE_FK";
            "Interperiod percentage rate"
			- @RateDerivation interperiodPercentageRate nullable cascade="all" databaseColumn="INTERPERIOD_PERCENTAGE_RATE_FK";
            "Geographical value"
			- @GeographicalValue geographicalValue cascade="none" nullable databaseColumn="GEOGRAPHICAL_VALUE_FK";
            
			"Provides access to Dimension"
            Repository DataSourceRepository {
            	@DataSource save(@DataSource entity);
            	delete;
            	protected List<@DataSource> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@DataSource findDataSource(String uuid);
            	List<String> findDatasourceDataGpeUuidLinkedToIndicatorVersion(Long indicatorVersionId);
				List<String> findIndicatorsLinkedWithIndicatorVersion(Long indicatorVersionId);
            }
        }  	   

		"Variable of data source"
        Entity DataSourceVariable {
        	databaseTable = "TB_DATA_SOURCES_VARIABLES"
        	hint="idSequence=DATA_SOURCES_VARIABLES"
        	
			"Variable"
			String variable not nullable;
			"Category"
			String category not nullable;
        }
        
        "Table values for quantity units"
	    Entity QuantityUnit {
        	databaseTable = "TB_LIS_QUANTITIES_UNITS"
        	hint="idSequence=QUANTITIES_UNITS"
			
			"Symbol of unit (example: km)"
			String symbol nullable;
			"Position of symbol of unit"
			- @QuantityUnitSymbolPositionEnum symbolPosition nullable;
       		"Title of unit"
       		- @InternationalString title cascade="all" not nullable databaseColumn="TITLE_FK";
       		
       		"Last update to optimistic locking"
			DateTimeTZ updateDate nullable;
       		
       		Repository QuantityUnitRepository {
       			findAll;
            	protected List<@QuantityUnit> findByQuery;
            	protected List<@QuantityUnit> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@QuantityUnit retrieveQuantityUnit(String uuid);
            	findByCondition(PagingParameter pagingParameter);
            	save;
            	delete;
			}
        }
        
        "Table values for geographical values"
	    Entity GeographicalValue {
        	databaseTable = "TB_LIS_GEOGR_VALUES"
        	hint="idSequence=GEOGR_VALUES"
			gap
			
			"Code"
			String code not nullable;
       		"Title"
       		- @InternationalString title cascade="all" nullable databaseColumn="TITLE_FK";
       		"Granularity"
			- @GeographicalGranularity granularity cascade="none" not nullable databaseColumn="GRANULARITY_FK";
       		"Latitude"
       		Double latitude nullable;
       		"Longitude"
       		Double longitude nullable;
       		"Order"
       		String order not nullable databaseColumn="GLOBAL_ORDER";
       		
       		"Last update to optimistic locking"
			DateTimeTZ updateDate nullable;
       		
       		Repository GeographicalValueRepository {
       			findAll;
            	protected List<@GeographicalValue> findByQuery;
            	protected List<@GeographicalValue> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@GeographicalValue retrieveGeographicalValue(String uuid);
            	@GeographicalValue findGeographicalValueByCode(String code);
            	List<@GeographicalValue> findGeographicalValuesByCodes(List<String> codes);
            	List<@GeographicalValue> findGeographicalValuesByGranularity(String granularityCode);
            	findByCondition(PagingParameter pagingParameter);
            	save;
            	delete;
			}
        }
        
        "Table values for geographical granularities"
	    Entity GeographicalGranularity {
        	databaseTable = "TB_LIS_GEOGR_GRANULARITIES"
        	hint="idSequence=GEOGR_GRANULARITIES"
			gap
			
			"Code"
			String code not nullable;
       		"Title"
       		- @InternationalString title cascade="all" nullable databaseColumn="TITLE_FK";
       		"Last update to optimistic locking"
			DateTimeTZ updateDate nullable;
       		
       		Repository GeographicalGranularityRepository {
       			findAll;
            	protected List<@GeographicalGranularity> findByQuery;
            	protected List<@GeographicalGranularity> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@GeographicalGranularity findGeographicalGranularityByCode(String code);
            	@GeographicalGranularity retrieveGeographicalGranularity(String uuid);
            	findByCondition(PagingParameter pagingParameter);
            	save;
            	delete;
			}
        }
        
		"Table values for units multipliers"
	    Entity UnitMultiplier {
        	databaseTable = "TB_LIS_UNITS_MULTIPLIERS"
        	hint="idSequence=UNITS_MULTIPLIERS"
			
			"Multiplier of percentage"
			Integer unitMultiplier nullable;
       		"Title of unit multiplier"
       		- @InternationalString title cascade="all" nullable databaseColumn="TITLE_FK";
       		"Last update to optimistic locking"
			DateTimeTZ updateDate nullable;
       		
       		Repository UnitMultiplierRepository {
       			findAll;
            	protected List<@UnitMultiplier> findByQuery;
            	protected List<@UnitMultiplier> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@UnitMultiplier retrieveUnitMultiplier(Integer unitMultiplierValue);
            	@UnitMultiplier retrieveUnitMultiplier(String unitMultiplierUuid);
            	List<@UnitMultiplier> findAllOrdered;
            	findByCondition(PagingParameter pagingParameter);
            	save;
            	delete;
			}
        }
        
       
        "Table view for Data basic information"
	    Entity DataDefinition {
        	databaseTable = "TV_CONSULTA"
			!auditable
			!optimisticLocking
			hint="strategy=IDENTITY"
			
			"Id"
			Long id not nullable databaseColumn="ID_CONSULTA" key;
			"uuid"
			String uuid nullable databaseColumn="UUID_CONSULTA" length="255";
			"Nombre de la consulta"
			String name nullable databaseColumn="NOMBRE_CONSULTA" length="255";
			"Query's type"
			String type nullable databaseColumn="TIPO_CONSULTA" length="255";
			"Query's parameters serialization"
			Clob query nullable databaseColumn="CONSULTA";
			"Px's Identifier"
			String pxUri not nullable databaseColumn="URI_PX" length="255";
			"Px's version when the query was created"
			String versionPx nullable databaseColumn="VERSION_PX" length="255";
			"Operation's identifier, should match with px's operation"
			String idOperacion not nullable databaseColumn="ID_OPERACION" length="7";
			"Creator"
			String creator not nullable databaseColumn="USUARIO_CREACION" length="255";
			"Creation date"
			DateTimestamp creationDate databaseColumn="FECHA_CREACION";
			"Last user who modified"
			String modifier nullable databaseColumn="USUARIO_MODIFICACION" length="255";
			"Modification date"
			DateTimestamp  updateDate nullable databaseColumn="FECHA_MODIFICACION";
			"Data modification date"
			DateTimestamp dataUpdateDate nullable databaseColumn="FECHA_MODIFICACION_DATOS";
			"Flag indicating whether the query is autoincremental or not, containing 'on' for yes"
			String autoincrement nullable databaseColumn="AUTOINCREMENTO";
			"Start date for available period"
			DateTimestamp availableStartDate nullable databaseColumn="FECHA_DISPONIBLE_INICIO";
			"End date for available period"
			DateTimestamp availableEndDate nullable databaseColumn="FECHA_DISPONIBLE_FIN";
			"Metadata which contains a # separated list enumerating all publications where the query is being referenced"
			Clob isPartOf nullable databaseColumn="IS_PART_OF";
			
       		Repository DataGpeRepository {
       			protected List<@DataDefinition> findByQuery;
            	protected List<@DataDefinition> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	List<String> findCurrentDataDefinitionsOperationsCodes;
            	List<@DataDefinition> findCurrentDataDefinitions;
            	List<@DataDefinition> findCurrentDataDefinitionsByOperationCode(String operationCode);
            	@DataDefinition findCurrentDataDefinition(String uuid);
            	List<String> findDataDefinitionsWithDataUpdatedAfter(DateTimestamp date);
            	List<String> filterDataDefinitionsWithDataUpdatedAfter(List<String> dataDefinitionsUuids, DateTimestamp date);
			}
        }
        
        "Table for improving access to last value given a geocode"
        Entity IndicatorVersionLastValueCache {
        	databaseTable = "TB_INDIC_VERSION_LAST_VALUE"
        	hint="idSequence=INDIC_VERSION_LAST_VALUE"
        	!auditable
        	!optimisticLocking
        	
        	"Geographical value"
			String geographicalCode not nullable key;
			"Indicator Version"
			- @IndicatorVersion indicatorVersion not nullable key cascade="none" fetch="lazy" databaseColumn="INDICATOR_VERSION_FK" <-> lastValuesCache ;
			"Last time value"
			String lastTimeValue not nullable;
			"Last time this object was updated"
			DateTimeTZ lastDataUpdated not nullable;
			
			Repository IndicatorVersionLastValueCacheRepository {
				delete;
				@IndicatorVersionLastValueCache save(@IndicatorVersionLastValueCache entity);
				List<@IndicatorVersionLastValueCache> findByQuery;
				
				List<@IndicatorVersion> findLastNIndicatorsVersionsWithGeoCodeAndSubjectCodeOrderedByLastUpdate(String subjectCode, String geoCode, int numResults);
				@IndicatorVersionLastValueCache retrieveLastValueCacheForIndicatorVersionWithGeoCode(String indicatorUuid, String geoCode);
				deleteWithIndicatorVersion(String indicatorUuid);
			}
        }
        
        "Table for improving access to last value given a geocode"
        Entity IndicatorInstanceLastValueCache {
        	databaseTable = "TB_INDIC_INST_LAST_VALUE"
        	hint="idSequence=INDIC_INST_LAST_VALUE"
        	!auditable
        	!optimisticLocking
        	
			"Indicator instance"
			- @IndicatorInstance indicatorInstance not nullable key cascade="none" databaseColumn="INDICATOR_INSTANCE_FK"  <-> lastValuesCache;
			"Geographical code"
			String geographicalCode not nullable key;
			"Last time value"
			String lastTimeValue not nullable;
			"Last time the object was updated"
			DateTimeTZ lastDataUpdated not nullable;
			
			Repository IndicatorInstanceLastValueCacheRepository {
				delete;
				@IndicatorInstanceLastValueCache save(@IndicatorInstanceLastValueCache entity);
				List<@IndicatorInstanceLastValueCache> findByQuery;
				
				List<@IndicatorInstance> findLastNIndicatorsInstancesWithGeoCodeInIndicatorsSystemOrderedByLastUpdate(String systemCode, String geoCode, int n);
				@IndicatorInstanceLastValueCache retrieveLastValueCacheForIndicatorInstanceWithGeoCode(String indicatorInstanceUuid, String geoCode);
				deleteWithIndicatorInstance(String indicatorInstanceUuid);
			}
        }

        "Table for improving access to geo coverages"
        Entity IndicatorVersionGeoCoverage {
        	databaseTable = "TB_IND_VERSION_GEO_COV"
        	hint="idSequence=IND_VERSION_GEO_COV"
        	!auditable
        	!optimisticLocking
        	
        	"Geographical value"
			- @GeographicalValue geographicalValue not nullable key cascade="none" databaseColumn="GEOGRAPHICAL_VALUE_FK";
			"Indicator Version"
			- @IndicatorVersion indicatorVersion not nullable key cascade="none" fetch="lazy" databaseColumn="INDICATOR_VERSION_FK";
			
			Repository IndicatorVersionGeoCoverageRepository {
				deleteCoverageForIndicatorVersion(@IndicatorVersion indicatorVersion);
				@IndicatorVersionGeoCoverage save(@IndicatorVersionGeoCoverage entity);
				List<@IndicatorVersionGeoCoverage> findByQuery;
				List<@GeographicalGranularity> retrieveGranularityCoverage(@IndicatorVersion indicatorVersion);
				
				List<GeographicalCodeVO> retrieveCodeCoverage(@IndicatorVersion indicatorVersion);
				List<GeographicalCodeVO> retrieveCodeCoverageFilteredByGranularity(@IndicatorVersion indicatorVersion, String geographicalGranularityUuid);
				List<GeographicalCodeVO> retrieveCodeCoverageFilteredByInstanceGeoValues(@IndicatorVersion indicatorVersion, String indicatorInstanceUuid);
				List<GeographicalCodeVO> retrieveCodeCoverageFilteredByInstanceGeoValuesByGranularity(@IndicatorVersion indicatorVersion, String indicatorInstanceUuid, String geographicalGranularityUuid);
				
				List<GeographicalValueVO> retrieveCoverage(@IndicatorVersion indicatorVersion);
				List<GeographicalValueVO> retrieveCoverageFilteredByGranularity(@IndicatorVersion indicatorVersion, String geographicalGranularityUuid);
				List<GeographicalValueVO> retrieveCoverageFilteredByInstanceGeoValues(@IndicatorVersion indicatorVersion, String indicatorInstanceUuid);
				List<GeographicalValueVO> retrieveCoverageFilteredByInstanceGeoValuesByGranularity(@IndicatorVersion indicatorVersion, String indicatorInstanceUuid, String geographicalGranularityUuid);
				
				List<@GeographicalValue> retrieveValueCoverageFilteredByGranularity(@IndicatorVersion indicatorVersion, String geographicalGranularityUuid);
			}
        }

        "Table for improving access to measure coverages"
        Entity IndicatorVersionMeasureCoverage {
        	databaseTable = "TB_IND_VERSION_MEAS_COV"
        	hint="idSequence=IND_VERSION_MEAS_COV"
        	
        	!auditable
        	!optimisticLocking
        	
			"Indicator Version"
			- @IndicatorVersion indicatorVersion not nullable key cascade="none" fetch="lazy" databaseColumn="INDICATOR_VERSION_FK";
        	"Geographical value"
			String measureCode not nullable key;
			
			- @Translation translation nullable;
			
			Repository IndicatorVersionMeasureCoverageRepository {
				deleteCoverageForIndicatorVersion(@IndicatorVersion indicatorVersion);
				@IndicatorVersionMeasureCoverage save(@IndicatorVersionMeasureCoverage entity);
				List<@IndicatorVersionMeasureCoverage> findByQuery;
				List<MeasureValue> retrieveCoverage(@IndicatorVersion indicatorVersion) throws MetamacException;
			}
        }
        
        "Table for improving access to measure coverages"
        Entity IndicatorVersionTimeCoverage {
        	databaseTable = "TB_IND_VERSION_TIME_COV"
        	hint="idSequence=IND_VERSION_TIME_COV"
        	
        	!auditable
        	!optimisticLocking
        	
			"Indicator Version"
			- @IndicatorVersion indicatorVersion not nullable key cascade="none" fetch="lazy" databaseColumn="INDICATOR_VERSION_FK";
        	"Geographical value"
			String timeValue not nullable key;
			String timeGranularity not nullable;
			- @Translation translation nullable; // not null?
			- @Translation granularityTranslation nullable; // not null?
			
			Repository IndicatorVersionTimeCoverageRepository {
				deleteCoverageForIndicatorVersion(@IndicatorVersion indicatorVersion);
				@IndicatorVersionTimeCoverage save(@IndicatorVersionTimeCoverage entity);
				List<@IndicatorVersionTimeCoverage> findByQuery;
				List<TimeValue> retrieveCoverage(@IndicatorVersion indicatorVersion) throws MetamacException;
				List<TimeValue> retrieveCoverageByGranularity(@IndicatorVersion indicatorVersion, String timeGranularityCode) throws MetamacException;
				List<TimeValue> retrieveCoverageFilteredByInstanceTimeValues(@IndicatorVersion indicatorVersion, List<String> instanceTimeValues) throws MetamacException;
				List<TimeGranularity> retrieveGranularityCoverage(@IndicatorVersion indicatorVersion) throws MetamacException;
				List<TimeGranularity> retrieveGranularityCoverageFilteredByInstanceTimeValues(@IndicatorVersion indicatorVersion, List<String> instanceTimeValues) throws MetamacException;
			}
        }
        
        "Table for Data basic information"
	    Entity Configuration {
        	databaseTable = "TB_CONFIGURATION"
        	hint="idSequence=CONFIGURATION"
			!auditable
			!optimisticLocking
			
			Long id not nullable key;			
			DateTimestamp lastSuccessfulGpeQueryDate databaseColumn="LAST_SUCCESSFUL_GPE_QUERY56";
			
			Repository ConfigurationRepository {
				findAll;
				@Configuration save(@Configuration entity);
			}
        }
        
        "Translations by code"
		Entity Translation {
			databaseTable="TB_TRANSLATIONS"
			hint="idSequence=TRANSLATIONS"
			!auditable
			!optimisticLocking
			gap
			
			"Id"
			Long id not nullable key;
			"Code"
			String code not nullable;
       		"Title"
       		- @InternationalString title cascade="all" not nullable databaseColumn="TITLE_FK";
       		"Summary title"
       		- @InternationalString titleSummary cascade="all" nullable databaseColumn="TITLE_SUMMARY_FK";
			
			Repository TranslationRepository {
            	protected List<@Translation> findByQuery;
            	protected List<@Translation> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@Translation findTranslationByCode(String code);
            	Map<String,@Translation> findTranslationsByCodes(List<String> translationCodes);
			}
		} 
	}
	
	Module tasks {
		basePackage=es.gobcan.istac.indicators.core.task
		
		"Provides access to background data operations"
    	Service TaskServiceFacade {
    		"Perform the population task"
    		List<MetamacExceptionItem> executePopulationIndicatorDataTask(String taskName, String indicatorUuid) throws MetamacException;
    		"Send success notification for de populate indicator data job"
    		createPopulateIndicatorDataSuccessBackgroundNotification(String user, String indicatorUuid);
    		"Send error notification for de populate indicator data job"
    		createPopulateIndicatorDataErrorBackgroundNotification(String user, String indicatorUuid, MetamacException metamacException);
    		
    		markAllInProgressTaskToFailed();
    		
    		"Schedule database dataset polling job"
			scheduleIndicatorsUpdateJob();
    	}
    	
    	"Provides access to background data operations"
    	Service TaskService {
    		> @TaskRepository
    		> @IndicatorsDataService
    		> @IndicatorsService  		
    		
			"Check if exists any kind of job task in the @param resourceId"
    		boolean existsTaskForResource(String resourceId) throws MetamacException;
    		"Plannify a scheduled task to populate indicator's data"
    		planifyPopulationIndicatorData(String indicatorUuid) throws MetamacException;
			"Perform the population task"
			List<MetamacExceptionItem> processPopulationIndicatorDataTask(String taskName, String indicatorUuid) throws MetamacException;
			"Send success notification for de populate indicator data job"
    		createPopulateIndicatorDataSuccessBackgroundNotification(String user, String indicatorUuid);
    		"Send error notification for de populate indicator data job"
    		createPopulateIndicatorDataErrorBackgroundNotification(String user, String indicatorUuid, MetamacException metamacException);
    		
    		"Creates a task"
			@Task createTask(@Task task) throws MetamacException;
			"Updates a task"
			@Task updateTask(@Task task) throws MetamacException;
			"Retrieves a task by job key"
			@Task retrieveTaskByJob(String jobKey) throws MetamacException;
			"Mark task as finished"
			markTaskAsFinished(String jobKey) throws MetamacException;	
			"Mark task as failed on application startup"
			markAllInProgressTaskToFailed();
			
			scheduleIndicatorsUpdateJob();
			
    	}
    	
    	// ----------------------------------------------------------------
		// 							ENTITIES
		// ---------------------------------------------------------------- 
		
		"Provides information about the tasks in background"	
	    Entity Task {
	   	 	databaseTable = "TB_TASKS"
	 		hint = "idSequence=TASKS"

			String job length="4000" key;
			-@TaskStatusTypeEnum status not nullable;
			String extensionPoint length="4000" nullable;
				   		      	
	   		Repository TaskRepository {
	   			save;
	   			delete;
				findByCondition(PagingParameter pagingParameter);
				findByQuery(String query, Map<String, Object> parameters, int maxResult);
				findByKey;
				deleteAndFlush(@Task task);
			}
	    }
	}
	
	// ----------------------------------------------------------------
	// 							ENUMS
	// ----------------------------------------------------------------
	
	Module dtos {    	
		basePackage=es.gobcan.istac.indicators.core.dto
		
		"Dto for indicators system"
	   	DataTransferObject IndicatorsSystemDto extends @AuditDto {
			
			"Unique uuid"
			String uuid;
			"Version number of this indicators system version"	
			String versionNumber;
			"Processing status"
			- @IndicatorsSystemProcStatusEnum procStatus;
			"Semantic identifier of statistic operation"
       		String code;
       		"Number of version in production"
       		String productionVersion;
       		"Number of version published"   		
			String publishedVersion;			
       		"Number of version archived"   		
			String archivedVersion;			
			
			"Date when the indicators system was sended to production validation"
			JAVADATE productionValidationDate;
			"User who sended to production validation"
			String productionValidationUser;
			"Date when the indicators system was sended to diffusion validation"
			JAVADATE diffusionValidationDate;
			"User who sended to diffusion validation"
			String diffusionValidationUser;
			"Date when the indicators system was published"
			JAVADATE publicationDate;
			"User who published"
			String publicationUser;
			"Date when the indicators system was archived"
			JAVADATE archiveDate;
			"User who archived"
			String archiveUser;			
	    }
	    
		"Dto for indicators system"
	   	DataTransferObject IndicatorsSystemHistoryDto {
			
			"Indicators System uuid"
			String indicatorsSystemUuid;
			"Version number of this indicators system version"	
			String versionNumber;
	    }
	    
		"Dto for indicators system. Summary information"
	   	DataTransferObject IndicatorsSystemSummaryDto {
			"Unique uuid"
			String uuid;
			"Code"
			String code;
       		"Production version: draft, in validation..."
       		- @IndicatorsSystemVersionSummaryDto productionVersion;
       		"Diffusion version: published, archived"
       		- @IndicatorsSystemVersionSummaryDto diffusionVersion;
	    }
	    
	    "Dto for version of indicators system. Summary information"
	   	DataTransferObject IndicatorsSystemVersionSummaryDto {
			"Version number of this indicators system version"	
			String versionNumber;
			"Processing status"
			- @IndicatorsSystemProcStatusEnum procStatus;
	    }
	    
	    "Dto for indicator"
	   	DataTransferObject IndicatorDto extends @AuditDto {
			"Unique uuid"
			String uuid;
			"Version number of this indicator version"	
			String versionNumber;
			"Code"
			String code;
			"View code"
			String viewCode;
			"Processing status"
			- @IndicatorProcStatusEnum procStatus;
       		"Title"
       		- @InternationalStringDto title;
       		"Acronym"
       		- @InternationalStringDto acronym;
       		"Subject code"
			String subjectCode;
			"Subject title"
			- @InternationalStringDto subjectTitle;
			"Concept"
       		- @InternationalStringDto conceptDescription;
			"Comments"
       		- @InternationalStringDto comments;
			"Notes"
       		- @InternationalStringDto notes;
       		"Quantity"
       		- @QuantityDto quantity;
       		
       		"Number of version in production"
       		String productionVersion;
       		"Number of version published"   		
			String publishedVersion;		
       		"Number of version archived"   		
			String archivedVersion;		
			
			"Indicates whether needs update its data or not"
			Boolean needsUpdate;
       		"Identifier in repository of observations"
       		String dataRepositoryId;       		
       		"Table name in repository of observations"
       		String dataRepositoryTableName; 				
			
			"Date when the indicators system was sended to production validation"
			JAVADATE productionValidationDate;
			"User who sended to production validation"
			String productionValidationUser;
			"Date when the indicators system was sended to diffusion validation"
			JAVADATE diffusionValidationDate;
			"User who sended to diffusion validation"
			String diffusionValidationUser;
			"Date when publication failed"
			JAVADATE publicationFailedDate;
			"User who publication failed"
			String publicationFailedUser;
			"Date when the indicator was published"
			JAVADATE publicationDate;
			"User who published"
			String publicationUser;
			"Date when the indicators system was archived"
			JAVADATE archiveDate;
			"User who archived"
			String archiveUser; 
			"Version to optimistic locking"
			Long versionOptimisticLocking;
			
			"True if user decied to receive notifications when data population fail in this indicator"
            Boolean notifyPopulationErrors not nullable;
            
            "True if a task related with the indicator is being executed in background"
			Boolean isTaskInBackground;
	    }
	    
	    "Dto for indicator. Summary information"
	   	DataTransferObject IndicatorSummaryDto {
			"Unique uuid"
			String uuid;
			"Code"
			String code;
			"True if user decied to receive notifications when data population fail in this indicator"
            Boolean notifyPopulationErrors not nullable;                        
       		"Production version: draft, in validation..."
       		- @IndicatorVersionSummaryDto productionVersion;
       		"Diffusion version: published, archived"
       		- @IndicatorVersionSummaryDto diffusionVersion;
       		
       		"True if a task related with the indicator is being executed in background"
			Boolean isTaskInBackground;
	    }
	    
	    "Dto for version of indicator. Summary information"
	   	DataTransferObject IndicatorVersionSummaryDto extends @AuditDto {
			"Version number of this indicator version"	
			String versionNumber;
			"Processing status"
			- @IndicatorProcStatusEnum procStatus;
       		"Title"
       		- @InternationalStringDto title;
       		"Subject code"
			String subjectCode;       		
       		"Subject title"
       		- @InternationalStringDto subjectTitle;
			"Indicates whether needs update its data or not"
			Boolean needsUpdate;

       		"Date when the indicators system was sended to production validation"
			JAVADATE productionValidationDate;
			"User who sended to production validation"
			String productionValidationUser;
			"Date when the indicators system was sended to diffusion validation"
			JAVADATE diffusionValidationDate;
			"User who sended to diffusion validation"
			String diffusionValidationUser;
			"Date when publication failed"
			JAVADATE publicationFailedDate;
			"User who publication failed"
			String publicationFailedUser;
			"Date when the indicator was published"
			JAVADATE publicationDate;
			"User who published"
			String publicationUser;
			"Date when the indicators system was archived"
			JAVADATE archiveDate;
			"User who archived"
			String archiveUser; 			
	    }

	    "Dto for dimension"
	   	DataTransferObject DimensionDto extends @AuditDto {
			"Unique uuid"
			String uuid;
			"Title"
			- @InternationalStringDto title;

            "Order in level"
			Long orderInLevel;
			"Parent dimension"
			String parentUuid;			
			"Version to optimistic locking"
			Long versionOptimisticLocking;			
	    }
	    
	    "Dto for data source"
	   	DataTransferObject DataSourceDto extends @AuditDto {
			gap
	   		
			"Unique uuid"
			String uuid;
			"Query in GPE"
			String queryUuid;
			"QueryUrn"
			String queryUrn;
		    "Query Environment"
            - @QueryEnvironmentEnum queryEnvironment;
            "Statistical Resource Query (Metamac) related with the data source"
            - @ExternalItemDto statResource;
			"Time variable"
			String timeVariable;
			"Time value, if time variable is not provided"
			String timeValue;
			"Geographical variable"
			String geographicalVariable;
			"Geographical value, if geographical variable is not provided"
			String geographicalValueUuid;
			"Other variables fixing one category"
			- List<@DataSourceVariableDto> otherVariables;
			"Absolute method. Must be OBS_VALUE or a variable value"
			String absoluteMethod;
			"Annual puntual rate"
			- @RateDerivationDto annualPuntualRate; 
			"Annual percentage rate"
			- @RateDerivationDto annualPercentageRate; 
			"Interperiod puntual rate"
			- @RateDerivationDto interperiodPuntualRate;
			"Interperiod percentage rate"
			- @RateDerivationDto interperiodPercentageRate;
			"Source survey code"
			String sourceSurveyCode;
			"Source survey title"
			- @InternationalStringDto sourceSurveyTitle;
			"Source survey acronym"
			- @InternationalStringDto sourceSurveyAcronym;
			"Source survey url"
			String sourceSurveyUrl;
			"Publishers"
			List<String> publishers;	
			"Version to optimistic locking"
			Long versionOptimisticLocking;		
	    }
	    
	    "Dto for variables and categories"
	   	DataTransferObject DataSourceVariableDto {
	   		"Variable"
			String variable;
			"Category fixed"
			String category;
	    }
	    
	    "Dto for indicator instance"
	   	DataTransferObject IndicatorInstanceDto extends @AuditDto {
			"Unique uuid"
			String uuid;
			"Code"
       		String code;
			"Title"
			- @InternationalStringDto title;
			"Indicator"
			String indicatorUuid;
        	"Time granularity"
        	- @IstacTimeGranularityEnum timeGranularity;
        	"Time values"
        	List<String> timeValues;
        	"Geographical granularity"
			String geographicalGranularityUuid;
			
        	"Geographical values"
			List<GeographicalValueBaseDto> geographicalValues;
			
            "Order in level"
			Long orderInLevel;
			"Parent dimension"
			String parentUuid;
			
			"Version to optimistic locking"
			Long versionOptimisticLocking;					    
	    }
	    
	    "AuditDto"
    	DataTransferObject AuditDto {
       		JAVADATE createdDate;
       		String createdBy;
       		JAVADATE lastUpdated;
       		String lastUpdatedBy;
    	}
    	
    	"Dto for structure of indicators system"
	   	DataTransferObject IndicatorsSystemStructureDto {
	   		"Uuid"
	   		String uuid;
			"Version number of this indicator version"	
			String versionNumber;
			"Elements: dimensions and indicators instances"
	   		- List<@ElementLevelDto> elements;
	   	}
	   	"Dto for element of level. Can be a dimension or an indicator instance"
	   	DataTransferObject ElementLevelDto {
	   		gap
	   		
	   		"Dimension"
	   		- @DimensionDto dimension;
	   		"Indicator instance"
	   		- @IndicatorInstanceDto indicatorInstance;
	   		"Subelements (only when this element is a dimension)"
	   		- List<@ElementLevelDto> subelements;
	   	}
	   	
	   	"Dto for quantity"
		DataTransferObject QuantityDto {
			gap
			
			"Type"
			- @QuantityTypeEnum type;
			"Unit"
			String unitUuid;
			"Multiplier of percentage. Default must be 1"
			Integer unitMultiplier;
			"Unit multiplier label"
			-@InternationalStringDto unitMultiplierLabel;
			"Number of significant digits to use when displaying the values of a metric concept"
			Integer significantDigits;
			"Number of decimal places to use for displaying the values of a metric concept"
			Integer decimalPlaces;
			"Min"
			Integer minimum;
			"Max"
			Integer maximum;
			"Indicator denominator of the fraction"
			String denominatorIndicatorUuid;
			"Indicator numerator of the fraction"
			String numeratorIndicatorUuid;
			"When Quantity is Ratio, true if is a percentage"
			Boolean isPercentage;
			"In percentages, descriptive text to display next to number that specifies what this is a percentage of"
			-@InternationalStringDto percentageOf;
			"Value base"
			Integer baseValue;
			"Time value base"
			String baseTime;
			"Geographical value base"
			String baseLocationUuid;
			"Indicator for base quantity"
			String baseQuantityIndicatorUuid;
		}

	    "Dto for rate derivation"
	    DataTransferObject RateDerivationDto {
	    	"Method type"
			- @RateDerivationMethodTypeEnum methodType;
			"Method"
			String method;
			"Quantity"
       		- @QuantityDto quantity;
       		"Rounding"
			- @RateDerivationRoundingEnum rounding;
	    }
	    
	   	"Dto for units of quantities"
    	DataTransferObject QuantityUnitDto extends @AuditDto {
	   		"Uuid"
	   		String uuid;
			"Symbol of unit (example: km)"
			String symbol;
			"Position of symbol of unit"
			- @QuantityUnitSymbolPositionEnum symbolPosition;
       		"Title of unit"
       		- @InternationalStringDto title;
       		
       		Long optimisticLockingVersion;	
    	}
    	
    	"Base Dto for geographical values"
    	DataTransferObject GeographicalValueBaseDto extends @AuditDto {
	   		"Code"
			String code;
	   		"Uuid"
	   		String uuid;
       		"Title"
       		- @InternationalStringDto title;
       		
       		Long optimisticLockingVersion;	
    	}
    	
    	"Dto for geographical values"
    	DataTransferObject GeographicalValueDto extends GeographicalValueBaseDto {
       		"Granularity"
			- @GeographicalGranularityDto granularity;
       		"Latitude"
       		Double latitude;
       		"Longitude"
       		Double longitude;
       		"Order"
       		String order;
    	}

    	"Dto for geographical granularities"
    	DataTransferObject GeographicalGranularityDto extends @AuditDto {
	   		"Uuid"
	   		String uuid;
	   		"Code"
			String code;
       		"Title"
       		- @InternationalStringDto title;
       		
       		Long optimisticLockingVersion;	
    	}
    	
    	"Dto for time values"
    	DataTransferObject TimeValueDto {
	   		"Time value"
			String timeValue;
       		"Title"
       		- @InternationalStringDto title;
       		"Summary title"
       		- @InternationalStringDto titleSummary;
       		"Granularity"
			- @IstacTimeGranularityEnum granularity;
    	}

    	"Dto for time granularities"
    	DataTransferObject TimeGranularityDto {
	   		"Granularity"
			- @IstacTimeGranularityEnum granularity;
       		"Title"
       		- @InternationalStringDto title;
       		"Summary title"
       		- @InternationalStringDto titleSummary;
    	}
    	
    	"Dto for subjects"
    	DataTransferObject SubjectDto {
	   		"Code"
	   		String code;
			"Title"
			- @InternationalStringDto title;
    	}
    	
    	"Dto for data basic definition"
    	DataTransferObject DataDefinitionDto {
	   		"Uuid"
	   		String uuid;
	   		"name"
	   		String name;
	   		"pxUri"
	   		String pxUri;
    	}
    	
    	"Dto for data structure"
    	DataTransferObject DataStructureDto {
    		"Uuid"
    		String uuid;
    		"Title"
    		String title;
    		"Urn associated"
    		String queryUrn;
    		"Survey code"
    		String surveyCode;
    		"Survey Title"
    		String surveyTitle;
    		"Publishers"
    		List<String> publishers;
    		"Variables"
    		List<String> variables;
    		"Temporal variable"
    		String temporalVariable; 
    		"Temporal value"
            String temporalValue; 
    		"Spatial variable"
    		List<String> spatialVariables;
    		"Spatial value"
    		- @GeographicalValueDto geographicalValueDto;
    		"Contvariable"
    		String contVariable;
    		"Labels for every value in every variable"
    		MapList valueLabels;
    		"Codes for every value in every variable"
    		MapList valueCodes;
    	}
    	
    	"Dto for data"
    	DataTransferObject DataDto {
	   		"Uuid"
	   		String uuid;
    	}
    	
    	"Dto for publish indicator result"
    	DataTransferObject PublishIndicatorResultDto {
	   		"Indicator"
	   		- @IndicatorDto indicator;
	   		"If publication fails, reason of error"
	   		MetamacException publicationFailedReason;
    	}
    	
		"Dto for units multipliers"
    	DataTransferObject UnitMultiplierDto extends @AuditDto {
    		"Uuid"
    		String uuid;
			"Multiplier of percentage"
			Integer unitMultiplier;
       		"Title"
       		- @InternationalStringDto title;
       		
       		Long optimisticLockingVersion;	
    	}
	}
	
	// ----------------------------------------------------------------
	// 							ENUMS
	// ----------------------------------------------------------------
	
	Module enums {    	
		basePackage=es.gobcan.istac.indicators.core.enume

		"Processing status of indicators system"
    	enum IndicatorsSystemProcStatusEnum {
    		DRAFT,
    		PRODUCTION_VALIDATION,
    		DIFFUSION_VALIDATION,
    		VALIDATION_REJECTED,
    		PUBLISHED,
    		ARCHIVED
    	}      
		"Processing status of indicator"
    	enum IndicatorProcStatusEnum {
    		DRAFT,
    		PRODUCTION_VALIDATION,
    		DIFFUSION_VALIDATION,
    		VALIDATION_REJECTED,
    		PUBLICATION_FAILED,    		
    		PUBLISHED,
    		ARCHIVED
    	}
    	
    	"Type of quantity"
    	enum QuantityTypeEnum {
    		QUANTITY,
    		AMOUNT,
    		MAGNITUDE,
    		FRACTION,
    		RATIO,
    		RATE,
    		INDEX,
    		CHANGE_RATE
    	}
    	
    	"Type of symbol position of quantity unit"
    	enum QuantityUnitSymbolPositionEnum {
    		START,
    		END
    	}	

	   	"Type of rate derivation"
    	enum RateDerivationMethodTypeEnum {
    		CALCULATE,
    		LOAD
    	}
    	
    	"Type of rate derivation"
    	enum RateDerivationRoundingEnum {
    		UPWARD,
    		DOWN
    	}
    	
    	"Types of Measure Dimensions"
    	enum MeasureDimensionTypeEnum {
    		ABSOLUTE,
    		ANNUAL_PERCENTAGE_RATE,
    		INTERPERIOD_PERCENTAGE_RATE,
    		ANNUAL_PUNTUAL_RATE,
    		INTERPERIOD_PUNTUAL_RATE
    	}
    	
    	"Indicator Data Dimensions"
    	enum IndicatorDataDimensionTypeEnum {
    		GEOGRAPHICAL,
    		TIME,
    		MEASURE
    	}
    	
    	"Indicator Data Attributes"
    	enum IndicatorDataAttributeTypeEnum {
    		CODE,
    		OBS_CONF
    	}
    	
    	"Roles"
    	enum RoleEnum {
    		ADMINISTRADOR,
    		TECNICO_SISTEMA_INDICADORES,
    		TECNICO_APOYO_PRODUCCION,
    		TECNICO_PRODUCCION,
    		TECNICO_APOYO_DIFUSION,
    		TECNICO_DIFUSION,
    		LECTOR,
    		ANY_ROLE_ALLOWED
    	}
    	
    	"Query Source"
        enum QueryEnvironmentEnum {
            METAMAC,
            GPE
        }
        
        "Task Status Type Enumerated"
    	enum TaskStatusTypeEnum {
    		IN_PROGRESS,
    		FAILED
    	}
	}
}