import "classpath:/btdesign/export/metamac-core-common-entity.btdesign"
import "classpath:/btdesign/metamac-core-common-dtos.btdesign"

Application Indicators {
    basePackage=es.gobcan.istac.indicators
    
    Module core {
		basePackage=es.gobcan.istac.indicators.core
		
		// ----------------------------------------------------------------
		// 							SERVICES
		// ----------------------------------------------------------------     
		
		"Provides access to indicators systems"
    	Service IndicatorsSystemsService {
    		> @IndicatorsSystemRepository
    		> @IndicatorsSystemVersionRepository
    		> @DimensionRepository
    		> @IndicatorInstanceRepository
    		> @ElementLevelRepository
    		> @IndicatorRepository
    		> @GeographicalValueRepository
    		> @GeographicalGranularityRepository
    		
    		// Indicators system
    		@IndicatorsSystemVersion createIndicatorsSystem(@IndicatorsSystemVersion indicatorsSystemVersion) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystem(String uuid, String versionNumber) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystemPublished(String uuid) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystemByCode(String code, String versionNumber) throws MetamacException;
	    	@IndicatorsSystemVersion retrieveIndicatorsSystemPublishedByCode(String code) throws MetamacException;
	    	List<@ElementLevel> retrieveIndicatorsSystemStructure(String uuid, String versionNumber) throws MetamacException;
	    	@IndicatorsSystemVersion updateIndicatorsSystemVersion(@IndicatorsSystemVersion indicatorsSystemVersion) throws MetamacException;
	    	deleteIndicatorsSystem(String uuid) throws MetamacException;
	    	List<@IndicatorsSystemVersion> findIndicatorsSystems() throws MetamacException;
	    	List<@IndicatorsSystemVersion> findIndicatorsSystemsPublished() throws MetamacException;
	    	@IndicatorsSystemVersion sendIndicatorsSystemToProductionValidation(String uuid) throws MetamacException;
	    	@IndicatorsSystemVersion sendIndicatorsSystemToDiffusionValidation(String uuid) throws MetamacException;
	    	@IndicatorsSystemVersion rejectIndicatorsSystemValidation(String uuid) throws MetamacException;
	    	@IndicatorsSystemVersion publishIndicatorsSystem(String uuid) throws MetamacException;	    		    	
	    	@IndicatorsSystemVersion archiveIndicatorsSystem(String uuid) throws MetamacException;	    		    	
	    	@IndicatorsSystemVersion versioningIndicatorsSystem(String uuid, @VersiontTypeEnum versionType) throws MetamacException;
	    	
	    	// Dimensions
	    	@Dimension createDimension(String indicatorsSystemUuid, @Dimension dimension) throws MetamacException;
	    	@Dimension updateDimension(@Dimension dimension) throws MetamacException;
	    	@Dimension updateDimensionLocation(String uuid, String parentTargetUuid, Long orderInLevel) throws MetamacException;
	    	@Dimension retrieveDimension(String uuid) throws MetamacException;
	    	deleteDimension(String uuid) throws MetamacException;
	    	List<@Dimension> findDimensions(String indicatorsSystemUuid, String indicatorsSystemVersionNumber) throws MetamacException;
	    	
	    	// Indicators instances
	    	@IndicatorInstance createIndicatorInstance(String indicatorsSystemUuid, @IndicatorInstance indicatorInstance) throws MetamacException;
	    	@IndicatorInstance updateIndicatorInstance(@IndicatorInstance indicatorInstance) throws MetamacException;
	    	@IndicatorInstance updateIndicatorInstanceLocation(String uuid, String parentTargetUuid, Long orderInLevel) throws MetamacException;
	    	@IndicatorInstance retrieveIndicatorInstance(String uuid) throws MetamacException;
	    	deleteIndicatorInstance(String uuid) throws MetamacException;
	    	List<@IndicatorInstance> findIndicatorsInstances(String indicatorsSystemUuid, String indicatorsSystemVersionNumber) throws MetamacException;
	    	
	    	// Geographical values
	    	@GeographicalValue retrieveGeographicalValue(String uuid) throws MetamacException;
	    	List<@GeographicalValue> findGeographicalValues(String geographicalGranularityUuid) throws MetamacException;

	    	// Geographical granularities
	    	@GeographicalGranularity retrieveGeographicalGranularity(String uuid) throws MetamacException;
	    	List<@GeographicalGranularity> findGeographicalGranularities() throws MetamacException;
    	}
    	
    	"Provides access to indicators"
    	Service IndicatorsService {
    		> @IndicatorRepository
    		> @IndicatorVersionRepository
    		> @DataSourceRepository
    		> @QuantityUnitRepository
    		
    		// Indicator
    		@IndicatorVersion createIndicator(@IndicatorVersion indicatorVersion) throws MetamacException;
	    	@Indicator retrieveIndicator(String uuid) throws MetamacException;
	    	@IndicatorVersion retrieveIndicator(String uuid, String versionNumber) throws MetamacException;
	    	@IndicatorVersion retrieveIndicatorPublished(String uuid) throws MetamacException;
	    	@IndicatorVersion retrieveIndicatorByCode(String code, String versionNumber) throws MetamacException;
	    	@IndicatorVersion retrieveIndicatorPublishedByCode(String code) throws MetamacException;
	    	@IndicatorVersion updateIndicatorVersion(@IndicatorVersion indicatorVersion) throws MetamacException;
	    	deleteIndicator(String uuid) throws MetamacException;
	    	List<@IndicatorVersion> findIndicators() throws MetamacException;
	    	List<@IndicatorVersion> findIndicatorsPublished() throws MetamacException;
	    	@IndicatorVersion sendIndicatorToProductionValidation(String uuid) throws MetamacException;
	    	@IndicatorVersion sendIndicatorToDiffusionValidation(String uuid) throws MetamacException;
	    	@IndicatorVersion rejectIndicatorValidation(String uuid) throws MetamacException;
	    	@IndicatorVersion publishIndicator(String uuid) throws MetamacException;	    		    	
	    	@IndicatorVersion archiveIndicator(String uuid) throws MetamacException;	    		    	
	    	@IndicatorVersion versioningIndicator(String uuid, @VersiontTypeEnum versionType) throws MetamacException;
	    	
	    	// Data sources
	    	@DataSource createDataSource(String indicatorUuid, @DataSource dataSource) throws MetamacException;
	    	@DataSource updateDataSource(@DataSource dataSource) throws MetamacException;
	    	@DataSource retrieveDataSource(String uuid) throws MetamacException;
	    	deleteDataSource(String uuid) throws MetamacException;
	    	List<@DataSource> findDataSources(String indicatorUuid, String indicatorVersionNumber) throws MetamacException;
	    	
	    	// Quantity units
	    	@QuantityUnit retrieveQuantityUnit(String uuid) throws MetamacException;
	    	List<@QuantityUnit> findQuantityUnits() throws MetamacException;
    	}   	
	    
	    "Provides access to indicators, indicators systems..."
    	Service IndicatorsServiceFacade {
			> @IndicatorsSystemsService
    		> @IndicatorsService
	    	
	    	// INDICATORS SYSTEMS
	    	"Creates an indicators system"
	    	@IndicatorsSystemDto createIndicatorsSystem(@IndicatorsSystemDto indicatorsSystemDto) throws MetamacException;
	    	"Updates metadata of an indicators system. This version can not be published or archived"
	    	@IndicatorsSystemDto updateIndicatorsSystem(@IndicatorsSystemDto indicatorsSystemDto) throws MetamacException;
	    	"Retrieves an indicators system. If versionNumber is not provided, retrieves last version"
	    	@IndicatorsSystemDto retrieveIndicatorsSystem(String uuid, String versionNumber) throws MetamacException;
	    	"Retrieves an indicators system published"
	    	@IndicatorsSystemDto retrieveIndicatorsSystemPublished(String uuid) throws MetamacException;
	    	"Retrieves an indicators system by code. If versionNumber is not provided, retrieves last version"
	    	@IndicatorsSystemDto retrieveIndicatorsSystemByCode(String code, String versionNumber) throws MetamacException;
	    	"Retrieves an indicators system by code. Retrieves diffusion version"
	    	@IndicatorsSystemDto retrieveIndicatorsSystemPublishedByCode(String code) throws MetamacException;
	    	"Deletes a version of an indicators system. Version to remove must be not published nor archived"
	    	deleteIndicatorsSystem(String uuid) throws MetamacException;
	    	"Sends indicators system to production validation"
	    	@IndicatorsSystemDto sendIndicatorsSystemToProductionValidation(String uuid) throws MetamacException;
	    	"Sends indicators system to diffusion validation"
	    	@IndicatorsSystemDto sendIndicatorsSystemToDiffusionValidation(String uuid) throws MetamacException;
	    	"Rejects validation of indicators system"
	    	@IndicatorsSystemDto rejectIndicatorsSystemValidation(String uuid) throws MetamacException;
	    	"Publishes indicators system"
	    	@IndicatorsSystemDto publishIndicatorsSystem(String uuid) throws MetamacException;	    		    	
	    	"Archives indicators system"
	    	@IndicatorsSystemDto archiveIndicatorsSystem(String uuid) throws MetamacException;	    		    	
	    	"Creates a version on draft of an indicators system in diffusion. Returns new version created"
	    	@IndicatorsSystemDto versioningIndicatorsSystem(String uuid, @VersiontTypeEnum versionType) throws MetamacException;
	    	"Finds indicators systems. Retrieves last versions"
	    	List<@IndicatorsSystemDto> findIndicatorsSystems() throws MetamacException;
	    	"Finds published indicators systems"
	    	List<@IndicatorsSystemDto> findIndicatorsSystemsPublished() throws MetamacException;
	    	"Retrieves indicators system structure: dimensions and indicators instances by levels. If versionNumber is not provided, retrieves last version"
	    	@IndicatorsSystemStructureDto retrieveIndicatorsSystemStructure(String uuid, String versionNumber) throws MetamacException;
	    	
	    	// DIMENSIONS
	    	"Creates a dimension"
	    	@DimensionDto createDimension(String indicatorsSystemUuid, @DimensionDto dimensionDto) throws MetamacException;
	    	"Updates metadata of dimension"
	    	@DimensionDto updateDimension(@DimensionDto dimensionDto) throws MetamacException;
	    	"Updates the location of dimension"
	    	@DimensionDto updateDimensionLocation(String uuid, String parentTargetUuid, Long orderInLevel) throws MetamacException;
	    	"Retrieves dimension"
	    	@DimensionDto retrieveDimension(String uuid) throws MetamacException;
	    	"Deletes dimension"
	    	deleteDimension(String uuid) throws MetamacException;
	    	"Retrieves all dimensions of a indicators system regardless of the level"
	    	List<@DimensionDto> findDimensions(String indicatorsSystemUuid, String indicatorsSystemVersionNumber) throws MetamacException;
	    	
	    	// INDICATORS INSTANCES	    	
	    	"Creates a indicator instance"
	    	@IndicatorInstanceDto createIndicatorInstance(String indicatorsSystemUuid, @IndicatorInstanceDto indicatorInstanceDto) throws MetamacException;
	    	"Updates metadata of indicator instance"
	    	@IndicatorInstanceDto updateIndicatorInstance(@IndicatorInstanceDto indicatorInstanceDto) throws MetamacException;
	    	"Updates the location of indicator instance"
	    	@IndicatorInstanceDto updateIndicatorInstanceLocation(String uuid, String parentTargetUuid, Long orderInLevel) throws MetamacException;
	    	"Retrieves indicator instance"
	    	@IndicatorInstanceDto retrieveIndicatorInstance(String uuid) throws MetamacException;
	    	"Deletes indicator instance"
	    	deleteIndicatorInstance(String uuid) throws MetamacException;
	    	"Retrieves all indicators instances of a indicators system regardless of the level"
	    	List<@IndicatorInstanceDto> findIndicatorsInstances(String indicatorsSystemUuid, String indicatorsSystemVersionNumber) throws MetamacException;

	    	// GEOGRAPHICAL VALUES
	    	"Retrieves geographical value"
	    	@GeographicalValueDto retrieveGeographicalValue(String uuid) throws MetamacException;
	    	"Find geographical values. Optionally, can specify geographical granularity"
	    	List<@GeographicalValueDto> findGeographicalValues(String geographicalGranularityUuid) throws MetamacException;

	    	// GEOGRAPHICAL GRANULARITIES
	    	"Retrieves geographical granularity"
	    	@GeographicalGranularityDto retrieveGeographicalGranularity(String uuid) throws MetamacException;
	    	"Retrieves all geographical granularities"
	    	List<@GeographicalGranularityDto> findGeographicalGranularities() throws MetamacException;
	    	
	    	// INDICATORS
	    	"Creates an indicator"
	    	@IndicatorDto createIndicator(@IndicatorDto indicatorDto) throws MetamacException;
	    	"Updates metadata of an indicator. This version can not be published or archived"
	    	@IndicatorDto updateIndicator(@IndicatorDto indicatorDto) throws MetamacException;
	    	"Retrieves an indicator. If versionNumber is not provided, retrieves last version"
	    	@IndicatorDto retrieveIndicator(String uuid, String versionNumber) throws MetamacException;
	    	"Retrieves an indicator published"
	    	@IndicatorDto retrieveIndicatorPublished(String uuid) throws MetamacException;
	    	"Retrieves an indicator by code. If versionNumber is not provided, retrieves last version"
	    	@IndicatorDto retrieveIndicatorByCode(String code, String versionNumber) throws MetamacException;
	    	"Retrieves an indicator by code. Retrieves diffusion version"
	    	@IndicatorDto retrieveIndicatorPublishedByCode(String code) throws MetamacException;
	    	"Deletes a version of an indicator. Version to remove must be not published nor archived"
	    	deleteIndicator(String uuid) throws MetamacException;
	    	"Sends indicator to production validation"
	    	@IndicatorDto sendIndicatorToProductionValidation(String uuid) throws MetamacException;
	    	"Sends indicator to diffusion validation"
	    	@IndicatorDto sendIndicatorToDiffusionValidation(String uuid) throws MetamacException;
	    	"Rejects validation of indicator"
	    	@IndicatorDto rejectIndicatorValidation(String uuid) throws MetamacException;
	    	"Publishes indicator"
	    	@IndicatorDto publishIndicator(String uuid) throws MetamacException;	    		    	
	    	"Archives indicator"
	    	@IndicatorDto archiveIndicator(String uuid) throws MetamacException;	    		    	
	    	"Creates a version on draft of an indicator in diffusion. Returns new version created"
	    	@IndicatorDto versioningIndicator(String uuid, @VersiontTypeEnum versionType) throws MetamacException;
	    	"Finds indicators. Retrieves last versions"
	    	List<@IndicatorDto> findIndicators() throws MetamacException;
	    	"Finds published indicators"
	    	List<@IndicatorDto> findIndicatorsPublished() throws MetamacException;
	    	
	    	// DATASOURCES
	    	"Creates a data source"
	    	@DataSourceDto createDataSource(String indicatorUuid, @DataSourceDto dataSourceDto) throws MetamacException;
	    	"Updates metadata of data source"
	    	@DataSourceDto updateDataSource(@DataSourceDto dataSourceDto) throws MetamacException;
	    	"Retrieves data source"
	    	@DataSourceDto retrieveDataSource(String uuid) throws MetamacException;
	    	"Deletes data source"
	    	deleteDataSource(String uuid) throws MetamacException;
	    	"Find data sources"
	    	List<@DataSourceDto> findDataSources(String indicatorUuid, String indicatorVersionNumber) throws MetamacException;
	    	
	    	// QUANTITY UNITS
	    	@QuantityUnitDto retrieveQuantityUnit(String uuid) throws MetamacException;
	    	List<@QuantityUnitDto> findQuantityUnits() throws MetamacException;
	    }

	    // ----------------------------------------------------------------
		// 							ENTITIES
		// ----------------------------------------------------------------        	
		"Indicators system entity"
		Entity IndicatorsSystem {
			databaseTable="TBL_INDICATORS_SYSTEMS"
			hint="idSequence=INDICATORS_SYSTEMS"
			gap
			
			"Semantic identifier of statistic operation. Non modifiable"
       		String code not nullable;
		
			// Can not do an OneToOne relation with IndicatorsSystemVersion because this produces a CyclicDependency with IndicatorsSystem
			"Version in production"
            - @IndicatorsSystemVersionInformation productionVersion nullable databaseColumn="PRODUCTION";
            "Version in diffusion"
            - @IndicatorsSystemVersionInformation diffusionVersion nullable databaseColumn="DIFFUSION";
            "True if indicator system is published"
            Boolean isPublished not nullable;
			"All versions"
			- Bag<@IndicatorsSystemVersion> versions cascade="all-delete-orphan" fetch="lazy" inverse <-> indicatorsSystem orderby="versionNumber asc";
			
			Repository IndicatorsSystemRepository {
		   		@IndicatorsSystem save(@IndicatorsSystem entity);
		   		delete;
            	protected List<@IndicatorsSystem> findByQuery;
            	protected List<@IndicatorsSystem> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@IndicatorsSystem retrieveIndicatorsSystem(String uuid);
            	List<@IndicatorsSystem> findIndicatorsSystems(String code);
			}
		} 
		
		"Version of indicators system entity"
		Entity IndicatorsSystemVersion {
			databaseTable="TBL_INDIC_SYSTEMS_VERSIONS"
			hint="idSequence=INDIC_SYSTEMS_VERSIONS"
			
			"Processing status"
			- @IndicatorsSystemProcStatusEnum procStatus not nullable;
			String versionNumber not nullable length="10";
       		"Uri of statistic operation in Gopestat"
       		String uriGopestat nullable;
       		"Title of statistic operation"
       		- @InternationalString title cascade="all" databaseColumn="TITLE_FK";
       		"Acronym of statistic operation"
       		- @InternationalString acronym cascade="all" nullable databaseColumn="ACRONYM_FK";
       		"Objetive of statistic operation"
       		- @InternationalString objetive cascade="all" nullable databaseColumn="OBJETIVE_FK";
       		"Description of statistic operation"
       		- @InternationalString description cascade="all" nullable databaseColumn="DESCRIPTION_FK";
       		
			"Date when the indicators system was sended to production validation"
			DateTimeTZ productionValidationDate nullable;
			"User who sended to production validation"
			String productionValidationUser nullable;
			"Date when the indicators system was sended to diffusion validation"
			DateTimeTZ diffusionValidationDate nullable;
			"User who sended to diffusion validation"
			String diffusionValidationUser nullable;
			"Date when the indicators system was published"
			DateTimeTZ publicationDate nullable;
			"User who published"
			String publicationUser nullable;
			"Date when the indicators system was archived"
			DateTimeTZ archiveDate nullable;
			"User who archived"
			String archiveUser nullable;
					
			// Relations
			"Indicator system"
			- @IndicatorsSystem indicatorsSystem not nullable cascade="none" databaseColumn="INDICATORS_SYSTEM_FK" <-> versions;
			"All children"
			- Bag<@ElementLevel> childrenAllLevels cascade="all-delete-orphan" fetch="lazy" inverse orderby="parent asc, orderInLevel asc" <-> indicatorsSystemVersion;
			"Children at first level"
			- Bag<@ElementLevel> childrenFirstLevel cascade="all-delete-orphan" fetch="lazy" inverse orderby="orderInLevel asc" <-> indicatorsSystemVersionFirstLevel;
		
			Repository IndicatorsSystemVersionRepository {
				@IndicatorsSystemVersion save(@IndicatorsSystemVersion entity);
				delete;
            	protected List<@IndicatorsSystemVersion> findByQuery;
            	protected List<@IndicatorsSystemVersion> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@IndicatorsSystemVersion retrieveIndicatorsSystemVersion(String uuid, String versionNumber);
            	List<@IndicatorsSystemVersion> findIndicatorsSystemVersions(String uriGopestat, @IndicatorsSystemProcStatusEnum procStatus);
			}
		} 
			    
		"Level at indicators system"
        Entity ElementLevel {
        	databaseTable = "TBL_ELEMENTS_LEVELS"
        	hint="idSequence=ELEMENTS_LEVELS"
        	gap
        	!auditable
        	
            "Order in level"
			Long orderInLevel not nullable;
			
			// Relations
			"Children"
			- Bag<@ElementLevel> children cascade="all-delete-orphan" inverse orderby="orderInLevel asc" <-> parent;
            "Parent"
            - @ElementLevel parent cascade="none" databaseColumn="PARENT_FK" nullable <-> children;
			"Dimension"
			- @Dimension dimension cascade="all" nullable databaseColumn="DIMENSION_FK" <-> elementLevel;
			"Indicator instance"
			- @IndicatorInstance indicatorInstance cascade="all" nullable databaseColumn="INDICATOR_INSTANCE_FK" <-> elementLevel;
            "Indicators system version"
			- @IndicatorsSystemVersion indicatorsSystemVersion cascade="none" fetch="lazy" not nullable databaseColumn="IND_SYSTEM_VERSION_ALL_FK" <-> childrenAllLevels;
			"Indicators system version"
			- @IndicatorsSystemVersion indicatorsSystemVersionFirstLevel cascade="none" fetch="lazy" nullable databaseColumn="IND_SYSTEM_VERSION_FIRST_FK" <-> childrenFirstLevel;
			
			"Provides access to ElementLevel"
            Repository ElementLevelRepository {
            	@ElementLevel save(@ElementLevel entity);
            	delete;
            }
        }  		
		
        "Dimension of indicators system"
        Entity Dimension {
        	databaseTable = "TBL_DIMENSIONS"
        	hint="idSequence=DIMENSIONS"
        	
            "Title"
            - @InternationalString title cascade="all" not nullable databaseColumn="TITLE_FK";

			// Relations
            "Element level"
            - @ElementLevel elementLevel cascade="none" not nullable inverse <-> dimension;
			            
			"Provides access to Dimension"
            Repository DimensionRepository {
            	@Dimension save(@Dimension entity);
            	protected List<@Dimension> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@Dimension findDimension(String uuid);
            }
        }  		
        
		"Instance of indicator"
        Entity IndicatorInstance {
        	databaseTable = "TBL_INDICATORS_INSTANCES"
        	hint="idSequence=INDICATORS_INSTANCES"
        	       		
			"Title"
       		- @InternationalString title cascade="all" not nullable databaseColumn="TITLE_FK";
        	"Temporal granularity"
        	- @TemporalGranularityEnum temporalGranularity nullable;
        	"Temporal value"
        	String temporalValue nullable;
			
			// Relations
            "Element level"
            - @ElementLevel elementLevel cascade="none" not nullable inverse <-> indicatorInstance;
        	"Indicator"
			- @Indicator indicator cascade="none" not nullable databaseColumn="INDICATOR_FK" <-> indicatorsInstances;
            "Geographical granularity"
			- @GeographicalGranularity geographicalGranularity cascade="none" nullable databaseColumn="GEOGRAPHICAL_GRANULARITY_FK";
            "Geographical value"
			- @GeographicalValue geographicalValue cascade="none" nullable databaseColumn="GEOGRAPHICAL_VALUE_FK";
            
			"Provides access to IndicatorInstance"
            Repository IndicatorInstanceRepository {
            	@IndicatorInstance save(@IndicatorInstance entity);
            	protected List<@IndicatorInstance> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@IndicatorInstance findIndicatorInstance(String uuid);
            	Boolean existAnyIndicatorInstance(String indicatorsSystemUuid, String indicatorsSystemVersionNumber);
            	List<String> findIndicatorsLinkedWithIndicatorsSystemVersion(Long indicatorsSystemVersionId);
            }
        }         
		
        BasicType IndicatorsSystemVersionInformation {
        	gap
        	"Id into database of IndicatorsSystemVersion"
    		Long idIndicatorsSystemVersion nullable databaseColumn="ID";
    		"Version number of IndicatorsSystemVersion"
    		String versionNumber nullable databaseColumn="VERSION_NUMBER" length="10";
    	}	
    	
		"Indicator entity"
		Entity Indicator {
			databaseTable="TBL_INDICATORS"
			hint="idSequence=INDICATORS"
			gap

			"Code. Non modifiable"
			String code not nullable;
			
			// Can not do an OneToOne relation with IndicatorVersion because this produces a CyclicDependency with Indicator
			"Version in production"
            - @IndicatorVersionInformation productionVersion nullable databaseColumn="PRODUCTION";
            "Version in diffusion"
            - @IndicatorVersionInformation diffusionVersion nullable databaseColumn="DIFFUSION";
            "True if indicator is published"
            Boolean isPublished not nullable;
			"All versions"
			- Bag<@IndicatorVersion> versions cascade="all-delete-orphan" fetch="lazy" inverse <-> indicator orderby="versionNumber asc";
			"Indicator instances"
			- Bag<@IndicatorInstance> indicatorsInstances cascade="none" fetch="lazy" inverse <-> indicator;
			
			Repository IndicatorRepository {
		   		@Indicator save(@Indicator entity);
		   		delete;
            	protected List<@Indicator> findByQuery;
            	protected List<@Indicator> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@Indicator retrieveIndicator(String uuid);
            	List<@Indicator> findIndicators(String code);
            	List<String> filterIndicatorsNotPublished(List<String> indicatorsUuid);
			}
		}
	    
		"Version of indicator entity"
		Entity IndicatorVersion {
			databaseTable="TBL_INDICATORS_VERSIONS"
			hint="idSequence=INDICATORS_VERSIONS"
			
			"Processing status"
			- @IndicatorProcStatusEnum procStatus not nullable;
			String versionNumber not nullable length="10";
       		"Title"
       		- @InternationalString title cascade="all" not nullable databaseColumn="TITLE_FK";
       		"Acronym"
       		- @InternationalString acronym cascade="all" nullable databaseColumn="ACRONYM_FK";
       		"Subject code"
			String subjectCode not nullable;
       		"Subject title"
       		- @InternationalString subjectTitle cascade="all" not nullable databaseColumn="SUBJECT_TITLE_FK";
       		"Concept associated with the indicator"
       		- @InternationalString conceptDescription cascade="all" nullable databaseColumn="CONCEPT_DESCRIPTION_FK";
			"Comments"
       		- @InternationalString comments cascade="all" nullable databaseColumn="COMMENTS_FK";
			"Comments url"
       		String commentsUrl nullable;
			"Notes"
       		- @InternationalString notes cascade="all" nullable databaseColumn="NOTES_FK";
       		"Notes url"
       		String notesUrl nullable;
       		
			"Date when the indicator was sended to production validation"
			DateTimeTZ productionValidationDate nullable;
			"User who sended to production validation"
			String productionValidationUser nullable;
			"Date when the indicator was sended to diffusion validation"
			DateTimeTZ diffusionValidationDate nullable;
			"User who sended to diffusion validation"
			String diffusionValidationUser nullable;
			"Date when the indicator was published"
			DateTimeTZ publicationDate nullable;
			"User who published"
			String publicationUser nullable;
			"Date when the indicator was archived"
			DateTimeTZ archiveDate nullable;
			"User who archived"
			String archiveUser nullable;
					
			// Relations
			"Indicator"
			- @Indicator indicator not nullable cascade="none" databaseColumn="INDICATOR_FK" <-> versions;
			"Quantity"
			- @Quantity quantity not nullable cascade="all" databaseColumn="QUANTITY_FK";
			"Data sources"
			- Bag<@DataSource> dataSources cascade="all-delete-orphan" fetch="lazy" inverse orderby="id asc" <-> indicatorVersion;
		
			Repository IndicatorVersionRepository {
				@IndicatorVersion save(@IndicatorVersion entity);
				delete;
            	protected List<@IndicatorVersion> findByQuery;
            	protected List<@IndicatorVersion> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@IndicatorVersion retrieveIndicatorVersion(String uuid, String versionNumber);
            	List<@IndicatorVersion> findIndicatorsVersions(@IndicatorProcStatusEnum procStatus);
            	@IndicatorVersion findOneIndicatorVersionLinkedToIndicator(String indicatorUuid);
			}
		}     	
		
	    "Metric characteristics of the indicator"
	    Entity Quantity {
        	databaseTable = "TBL_QUANTITIES"
        	hint="idSequence=QUANTITIES"
        	gap

	    	"Type"
			- @QuantityTypeEnum quantityType not nullable;
			"Multiplier of percentage"
			Integer unitMultiplier not nullable;
			"Number of significant digits to use when displaying the values of a metric concept"
			Integer significantDigits nullable;
			"Number of decimal places to use for displaying the values of a metric concept"
			Integer decimalPlaces nullable;
			"Min"
			Integer minimum nullable;
			"Max"
			Integer maximum nullable;
			"When Quantity is Ratio, true if is a percentage"
			Boolean isPercentage nullable;
			"In percentages, descriptive text to display next to number that specifies what this is a percentage of"
			- @InternationalString percentageOf cascade="all" nullable databaseColumn="PERCENTAGE_OF_FK";
			
			"Value base"
			Integer baseValue nullable;
			"Temporal value base"
			String baseTime nullable;
			
			// Relations
			"Unit"
			- @QuantityUnit unit not nullable cascade="none" databaseColumn="UNIT_FK";
			"Numerator of the fraction"
			- @Indicator numerator nullable cascade="none" databaseColumn="NUMERATOR_FK";
			"Denominator of the fraction"
			- @Indicator denominator nullable cascade="none" databaseColumn="DENOMINATOR_FK";
			"Base quantity"
			- @Indicator baseQuantity nullable cascade="none" databaseColumn="BASE_QUANTITY_FK";
            "Geographical value base"
			- @GeographicalValue baseLocation cascade="none" nullable databaseColumn="BASE_LOCATION_FK";
	    }
	    
	    "Metric characteristics of a data source of indicator"
	    Entity RateDerivation {
        	databaseTable = "TBL_RATES_DERIVATIONS"
        	hint="idSequence=RATES_DERIVATIONS"

	    	"Method type"
			- @RateDerivationMethodTypeEnum methodType not nullable;
			"Method"
			String method not nullable;
			"Rounding"
			- @RateDerivationRoundingEnum rounding nullable;

			// Relations
			"Quantity"
			- @Quantity quantity not nullable cascade="all" databaseColumn="QUANTITY_FK";
	    }
	    
        BasicType IndicatorVersionInformation {
        	gap
        	"Id into database of IndicatorVersion"
    		Long idIndicatorVersion nullable databaseColumn="ID";
    		"Version number of IndicatorVersion"
    		String versionNumber nullable databaseColumn="VERSION_NUMBER" length="10";
    	}			
    	
		"Data source of indicator"
        Entity DataSource {
        	databaseTable = "TBL_DATA_SOURCES"
        	hint="idSequence=DATA_SOURCES"
        	
			"Query in GPE"
			String queryGpe not nullable;
			"Px"
			String px not nullable;
			"Temporal variable"
			String temporalVariable not nullable;
			"Geographical variable"
			String geographicalVariable not nullable;
			"Other variables fixing one category"
			- Bag<@DataSourceVariable> otherVariables cascade="all-delete-orphan" fetch="lazy" inverse orderby="id asc" databaseColumn="DATA_SOURCE_FK";
			
			// Relations
            "Indicator version"
			- @IndicatorVersion indicatorVersion cascade="none" fetch="lazy" nullable databaseColumn="INDICATOR_VERSION_FK" <-> dataSources;
            "Interperiod rate"
			- @RateDerivation interperiodRate not nullable cascade="all" databaseColumn="INTERPERIOD_RATE_FK";
            "Annual rate"
			- @RateDerivation annualRate not nullable cascade="all" databaseColumn="ANNUAL_RATE_FK";
            
			"Provides access to Dimension"
            Repository DataSourceRepository {
            	@DataSource save(@DataSource entity);
            	delete;
            	protected List<@DataSource> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@DataSource findDataSource(String uuid);
				List<String> findIndicatorsLinkedWithIndicatorVersion(Long indicatorVersionId);
            }
        }  	   

		"Variable of data source"
        Entity DataSourceVariable {
        	databaseTable = "TBL_DATA_SOURCES_VARIABLES"
        	hint="idSequence=DATA_SOURCES_VARIABLES"
        	
			"Variable"
			String variable not nullable;
			"Category"
			String category not nullable;
        }
        
        "Table values for quantity units"
	    Entity QuantityUnit {
        	databaseTable = "LIS_QUANTITIES_UNITS"
        	hint="idSequence=QUANTITIES_UNITS"
			!auditable
			
			"Symbol of unit (example: km)"
			String symbol nullable;
			"Position of symbol of unit"
			- @QuantityUnitSymbolPositionEnum symbolPosition not nullable;
       		"Title of unit"
       		- @InternationalString title cascade="all" nullable databaseColumn="TITLE_FK";
       		
       		Repository QuantityUnitRepository {
       			findAll;
            	protected List<@QuantityUnit> findByQuery;
            	protected List<@QuantityUnit> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@QuantityUnit retrieveQuantityUnit(String uuid);
			}
        }
        
        "Table values for geographical values"
	    Entity GeographicalValue {
        	databaseTable = "LIS_GEOGR_VALUES"
        	hint="idSequence=GEOGR_VALUES"
			!auditable
			gap
			
			"Code"
			String code not nullable;
       		"Title"
       		- @InternationalString title cascade="all" nullable databaseColumn="TITLE_FK";
       		"Granularity"
			- @GeographicalGranularity granularity cascade="none" not nullable databaseColumn="GRANULARITY_FK";
       		"Latitude"
       		String latitude nullable;
       		"Longitude"
       		String longitude nullable;
       		
       		Repository GeographicalValueRepository {
       			findAll;
            	protected List<@GeographicalValue> findByQuery;
            	protected List<@GeographicalValue> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@GeographicalValue retrieveGeographicalValue(String uuid);
            	List<@GeographicalValue> findGeographicalValues(String geographicalGranularityUuid);
			}
        }
        
        "Table values for geographical granularities"
	    Entity GeographicalGranularity {
        	databaseTable = "LIS_GEOGR_GRANULARITIES"
        	hint="idSequence=GEOGR_GRANULARITIES"
			!auditable
			gap
			
			"Code"
			String code not nullable;
       		"Title"
       		- @InternationalString title cascade="all" nullable databaseColumn="TITLE_FK";
       		
       		Repository GeographicalGranularityRepository {
       			findAll;
            	protected List<@GeographicalGranularity> findByQuery;
            	protected List<@GeographicalGranularity> findByQuery(String query, Map<String, Object> parameters, int maxResult);
            	@GeographicalGranularity retrieveGeographicalGranularity(String uuid);
			}
        }
	}
	
	// ----------------------------------------------------------------
	// 							ENUMS
	// ----------------------------------------------------------------
	
	Module dtos {    	
		basePackage=es.gobcan.istac.indicators.core.dto
		
		"Dto for indicators system"
	   	DataTransferObject IndicatorsSystemDto extends @AuditDto {
			
			"Unique uuid"
			String uuid;
			"Version number of this indicators system version"	
			String versionNumber;
			"Processing status"
			- @IndicatorsSystemProcStatusEnum procStatus;
			"Semantic identifier of statistic operation"
       		String code;
       		"Uri of statistic operation in Gopestat"
       		String uriGopestat;
       		"Title of statistic operation"
       		- @InternationalStringDto title;
       		"Acronym of statistic operation"
       		- @InternationalStringDto acronym;
       		"Description of statistic operation"
       		- @InternationalStringDto description;
       		"Objetive of statistic operation"
       		- @InternationalStringDto objetive;			
       		"Number of version in production"
       		String productionVersion;
       		"Number of version in diffusion"   		
			String diffusionVersion;			
			
			"Date when the indicators system was sended to production validation"
			JAVADATE productionValidationDate;
			"User who sended to production validation"
			String productionValidationUser;
			"Date when the indicators system was sended to diffusion validation"
			JAVADATE diffusionValidationDate;
			"User who sended to diffusion validation"
			String diffusionValidationUser;
			"Date when the indicators system was published"
			JAVADATE publicationDate;
			"User who published"
			String publicationUser;
			"Date when the indicators system was archived"
			JAVADATE archiveDate;
			"User who archived"
			String archiveUser;
	    }
	    
	    "Dto for indicator"
	   	DataTransferObject IndicatorDto extends @AuditDto {
			
			"Unique uuid"
			String uuid;
			"Version number of this indicator version"	
			String versionNumber;
			"Code"
			String code;
			"Processing status"
			- @IndicatorProcStatusEnum procStatus;
       		"Title"
       		- @InternationalStringDto title;
       		"Acronym"
       		- @InternationalStringDto acronym;
       		"Subject code"
			String subjectCode;
			"Subject title"
			- @InternationalStringDto subjectTitle;
			"Concept"
       		- @InternationalStringDto conceptDescription;
			"Comments"
       		- @InternationalStringDto comments;
			"Comments url"
       		String commentsUrl;
			"Notes"
       		- @InternationalStringDto notes;
       		"Notes url"
       		String notesUrl;
       		"Quantity"
       		- @QuantityDto quantity;
       		
       		"Number of version in production"
       		String productionVersion;
       		"Number of version in diffusion"   		
			String diffusionVersion;			
			
			"Date when the indicators system was sended to production validation"
			JAVADATE productionValidationDate;
			"User who sended to production validation"
			String productionValidationUser;
			"Date when the indicators system was sended to diffusion validation"
			JAVADATE diffusionValidationDate;
			"User who sended to diffusion validation"
			String diffusionValidationUser;
			"Date when publication failed"
			JAVADATE publicationFailedDate;
			"User who publication failed"
			String publicationFailedUser;
			"Date when the indicators system was published"
			JAVADATE publicationDate;
			"User who published"
			String publicationUser;
			"Date when the indicators system was archived"
			JAVADATE archiveDate;
			"User who archived"
			String archiveUser;       		    
	    }

	    "Dto for dimension"
	   	DataTransferObject DimensionDto extends @AuditDto {
			"Unique uuid"
			String uuid;
			"Title"
			- @InternationalStringDto title;

            "Order in level"
			Long orderInLevel;
			"Parent dimension"
			String parentUuid;			
	    }
	    
	    "Dto for data source"
	   	DataTransferObject DataSourceDto extends @AuditDto {
			gap
	   		
			"Unique uuid"
			String uuid;
			"Query in GPE"
			String queryGpe;
			"Px"
			String px;
			"Temporal variable"
			String temporalVariable;
			"Geographical variable"
			String geographicalVariable;
			"Other variables fixing one category"
			- List<@DataSourceVariableDto> otherVariables;
			"Interperiod rate"
			- @RateDerivationDto interperiodRate;
			"Annual rate"
			- @RateDerivationDto annualRate; 
	    }
	    
	    "Dto for variables and categories"
	   	DataTransferObject DataSourceVariableDto {
	   		"Variable"
			String variable;
			"Category fixed"
			String category;
	    }
	    
	    "Dto for indicator instance"
	   	DataTransferObject IndicatorInstanceDto extends @AuditDto {
			"Unique uuid"
			String uuid;
			"Title"
			- @InternationalStringDto title;
			"Indicator"
			String indicatorUuid;
        	"Temporal granularity"
        	- @TemporalGranularityEnum temporalGranularity;
        	"Temporal value"
        	String temporalValue;
        	"Geographical granularity"
			String geographicalGranularityUuid;
        	"Geographical value"
			String geographicalValueUuid;
			
            "Order in level"
			Long orderInLevel;
			"Parent dimension"
			String parentUuid;
	    }
	    
	    "AuditDto"
    	DataTransferObject AuditDto {
       		JAVADATE createdDate;
       		String createdBy;
       		JAVADATE lastUpdated;
       		String lastUpdatedBy;
    	}
    	
    	"Dto for structure of indicators system"
	   	DataTransferObject IndicatorsSystemStructureDto {
	   		"Uuid"
	   		String uuid;
			"Version number of this indicator version"	
			String versionNumber;
			"Elements: dimensions and indicators instances"
	   		- List<@ElementLevelDto> elements;
	   	}
	   	"Dto for element of level. Can be a dimension or an indicator instance"
	   	DataTransferObject ElementLevelDto {
	   		gap
	   		
	   		"Dimension"
	   		- @DimensionDto dimension;
	   		"Indicator instance"
	   		- @IndicatorInstanceDto indicatorInstance;
	   		"Subelements (only when this element is a dimension)"
	   		- List<@ElementLevelDto> subelements;
	   	}
	   	
	   	"Dto for quantity"
		DataTransferObject QuantityDto {
			gap
			
			"Type"
			- @QuantityTypeEnum type;
			"Unit"
			String unitUuid;
			"Multiplier of percentage. Default must be 1"
			Integer unitMultiplier;
			"Number of significant digits to use when displaying the values of a metric concept"
			Integer significantDigits;
			"Number of decimal places to use for displaying the values of a metric concept"
			Integer decimalPlaces;
			"Min"
			Integer minimum;
			"Max"
			Integer maximum;
			"Indicator denominator of the fraction"
			String denominatorIndicatorUuid;
			"Indicator numerator of the fraction"
			String numeratorIndicatorUuid;
			"When Quantity is Ratio, true if is a percentage"
			Boolean isPercentage;
			"In percentages, descriptive text to display next to number that specifies what this is a percentage of"
			-@InternationalStringDto percentageOf;
			"Value base"
			Integer baseValue;
			"Temporal value base"
			String baseTime;
			"Geographical value base"
			String baseLocationUuid;
			"Indicator for base quantity"
			String baseQuantityIndicatorUuid;
		}

	    "Dto for rate derivation"
	    DataTransferObject RateDerivationDto {
	    	"Method type"
			- @RateDerivationMethodTypeEnum methodType;
			"Method"
			String method;
			"Quantity"
       		- @QuantityDto quantity;
       		"Rounding"
			- @RateDerivationRoundingEnum rounding;
	    }
	    
	   	"Dto for units of quantities"
    	DataTransferObject QuantityUnitDto {
	   		"Uuid"
	   		String uuid;
			"Symbol of unit (example: km)"
			String symbol;
			"Position of symbol of unit"
			- @QuantityUnitSymbolPositionEnum symbolPosition;
       		"Title of unit"
       		- @InternationalStringDto title;
    	}
    	
    	"Dto for geographical values"
    	DataTransferObject GeographicalValueDto {
	   		"Uuid"
	   		String uuid;
	   		"Code"
			String code;
       		"Title"
       		- @InternationalStringDto title;
       		"Granularity"
			String granularityUuid;
       		"Latitude"
       		Double latitude;
       		"Longitude"
       		Double longitude;
    	}

    	"Dto for geographical granularities"
    	DataTransferObject GeographicalGranularityDto {
	   		"Uuid"
	   		String uuid;
	   		"Code"
			String code;
       		"Title"
       		- @InternationalStringDto title;
    	}

	}
	
	// ----------------------------------------------------------------
	// 							ENUMS
	// ----------------------------------------------------------------
	
	Module enums {    	
		basePackage=es.gobcan.istac.indicators.core.enume

		"Processing status of indicators system"
    	enum IndicatorsSystemProcStatusEnum {
    		DRAFT,
    		PRODUCTION_VALIDATION,
    		DIFFUSION_VALIDATION,
    		VALIDATION_REJECTED,
    		PUBLISHED,
    		ARCHIVED
    	}      
		"Processing status of indicator"
    	enum IndicatorProcStatusEnum {
    		DRAFT,
    		PRODUCTION_VALIDATION,
    		DIFFUSION_VALIDATION,
    		VALIDATION_REJECTED,
    		PUBLICATION_FAILED,    		
    		PUBLISHED,
    		ARCHIVED
    	}	
    	"Type of version of the change"
    	enum VersiontTypeEnum {
    		MAJOR,
    		MINOR
    	}
    	
    	"Type of quantity"
    	enum QuantityTypeEnum {
    		QUANTITY,
    		AMOUNT,
    		MAGNITUDE,
    		FRACTION,
    		RATIO,
    		RATE,
    		INDEX,
    		CHANGE_RATE
    	}
    	
    	"Type of symbol position of quantity unit"
    	enum QuantityUnitSymbolPositionEnum {
    		START,
    		END
    	}	

	   	"Type of rate derivation"
    	enum RateDerivationMethodTypeEnum {
    		CALCULATE,
    		LOAD
    	}
    	
    	"Type of rate derivation"
    	enum RateDerivationRoundingEnum {
    		UPWARD,
    		DOWN
    	}
    	
    	"Temporal granularities"
    	enum TemporalGranularityEnum {
    		YEARLY,
    		BIYEARLY,
    		QUARTERLY,
    		MONTHLY,
    		WEEKLY,
    		DAILY
    	}		
	}
}